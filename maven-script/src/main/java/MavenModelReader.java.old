import org.apache.maven.model.Model;
import org.apache.maven.model.Plugin;
import org.apache.maven.model.PluginExecution;
import org.apache.maven.model.Dependency;
import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
import org.codehaus.plexus.util.xml.Xpp3Dom;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;
import java.util.ArrayList;
import java.util.LinkedHashMap;

public class MavenModelReader {
    
    public static void main(String[] args) {
        boolean generateNxConfig = false;
        boolean useStdin = false;
        List<String> pomPaths = new ArrayList<>();
        
        // Parse arguments
        for (String arg : args) {
            if ("--nx".equals(arg)) {
                generateNxConfig = true;
            } else if ("--stdin".equals(arg)) {
                useStdin = true;
            } else {
                pomPaths.add(arg);
            }
        }
        
        try {
            // Read from stdin if requested
            if (useStdin) {
                pomPaths = readPomPathsFromStdin();
            } else if (pomPaths.isEmpty()) {
                pomPaths.add("pom.xml"); // Default
            }
            
            if (generateNxConfig) {
                generateBatchNxProjectConfigurations(pomPaths);
            } else {
                // Single file analysis mode (backwards compatibility)
                if (pomPaths.size() == 1) {
                    Model model = readPomFile(pomPaths.get(0));
                    System.out.println("Project: " + model.getGroupId() + ":" + model.getArtifactId());
                    System.out.println("Packaging: " + model.getPackaging());
                    System.out.println();
                    analyzeLifecycleBindings(model);
                } else {
                    System.err.println("Multiple files can only be processed with --nx flag");
                    System.exit(1);
                }
            }
            
        } catch (Exception e) {
            System.err.println("Error processing POM files: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    private static Model readPomFile(String pomPath) throws IOException, org.codehaus.plexus.util.xml.pull.XmlPullParserException {
        MavenXpp3Reader reader = new MavenXpp3Reader();
        return reader.read(new FileReader(new File(pomPath)));
    }
    
    private static List<String> readPomPathsFromStdin() throws IOException {
        List<String> pomPaths = new ArrayList<>();
        java.io.BufferedReader reader = new java.io.BufferedReader(new java.io.InputStreamReader(System.in));
        String line;
        
        System.err.println("INFO: Reading POM paths from stdin...");
        
        while ((line = reader.readLine()) != null) {
            line = line.trim();
            if (!line.isEmpty()) {
                pomPaths.add(line);
            }
        }
        
        System.err.println("INFO: Read " + pomPaths.size() + " POM paths from stdin");
        return pomPaths;
    }
    
    private static void generateBatchNxProjectConfigurations(List<String> pomPaths) {
        // Configurable batch size to prevent system overload
        final int BATCH_SIZE = Integer.parseInt(System.getProperty("maven.batch.size", "50"));
        final int GC_INTERVAL = Integer.parseInt(System.getProperty("maven.gc.interval", "200"));
        
        Map<String, Object> batchResult = new LinkedHashMap<>();
        
        System.err.println("INFO: Starting batch processing of " + pomPaths.size() + " Maven projects");
        System.err.println("INFO: Using batch size: " + BATCH_SIZE + ", GC interval: " + GC_INTERVAL);
        long startTime = System.currentTimeMillis();
        
        int processed = 0;
        int successful = 0;
        int failed = 0;
        
        // Process files in batches
        for (int batchStart = 0; batchStart < pomPaths.size(); batchStart += BATCH_SIZE) {
            int batchEnd = Math.min(batchStart + BATCH_SIZE, pomPaths.size());
            int batchNumber = (batchStart / BATCH_SIZE) + 1;
            int totalBatches = (pomPaths.size() + BATCH_SIZE - 1) / BATCH_SIZE;
            
            System.err.println("INFO: Processing batch " + batchNumber + "/" + totalBatches + 
                " (files " + (batchStart + 1) + "-" + batchEnd + ")");
            
            long batchStartTime = System.currentTimeMillis();
            int batchSuccessful = 0;
            int batchFailed = 0;
            
            for (int i = batchStart; i < batchEnd; i++) {
                String pomPath = pomPaths.get(i);
                processed++;
                
                try {
                    System.err.println("DEBUG: Processing " + pomPath);
                    Model model = readPomFile(pomPath);
                    Map<String, Object> nxConfig = generateNxProjectConfigurationMap(model);
                    
                    // Use the directory name as the key (relative path from workspace root)
                    File pomFile = new File(pomPath);
                    String projectRoot = pomFile.getParent();
                    if (projectRoot == null) {
                        projectRoot = ".";
                    }
                    
                    // Convert absolute path to relative path
                    if (projectRoot.startsWith("/")) {
                        // Find workspace root by looking for common patterns
                        String workspacePattern = "/home/jason/projects/triage/java/quarkus/";
                        if (projectRoot.startsWith(workspacePattern)) {
                            projectRoot = projectRoot.substring(workspacePattern.length());
                            if (projectRoot.isEmpty()) {
                                projectRoot = ".";
                            }
                        }
                    }
                    
                    batchResult.put(projectRoot, nxConfig);
                    successful++;
                    batchSuccessful++;
                    
                    String projectName = nxConfig.get("name") != null ? nxConfig.get("name").toString() : "unknown";
                    System.err.println("DEBUG: Successfully processed " + projectName + " at " + projectRoot);
                    
                } catch (Exception e) {
                    failed++;
                    batchFailed++;
                    System.err.println("ERROR: Failed to process " + pomPath + ": " + e.getMessage());
                    System.err.println("DEBUG: Exception details: " + e.getClass().getSimpleName());
                    // Continue processing other files
                }
            }
            
            long batchDuration = System.currentTimeMillis() - batchStartTime;
            int batchSize = batchEnd - batchStart;
            System.err.println("INFO: Batch " + batchNumber + " completed in " + batchDuration + "ms - " +
                "Success: " + batchSuccessful + "/" + batchSize + " (Failed: " + batchFailed + ")");
            
            // Force garbage collection periodically to manage memory
            if (processed % GC_INTERVAL == 0) {
                System.err.println("DEBUG: Running garbage collection after " + processed + " files");
                System.gc();
                
                // Brief pause to let GC complete and reduce system load
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            
            // Log overall progress
            System.err.println("INFO: Overall progress: " + processed + "/" + pomPaths.size() + 
                " (" + (processed * 100 / pomPaths.size()) + "%) - " +
                "Total Success: " + successful + ", Total Failed: " + failed);
        }
        
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;
        
        System.err.println("INFO: Batch processing completed in " + duration + "ms");
        System.err.println("INFO: Final results - Total: " + processed + 
            ", Successful: " + successful + ", Failed: " + failed);
        System.err.println("INFO: Generating JSON output for " + batchResult.size() + " projects");
        
        // Final garbage collection before JSON generation
        System.gc();
        
        // Output as JSON
        System.out.println(mapToJson(batchResult));
        
        System.err.println("INFO: JSON output generation completed");
    }
    
    private static void generateNxProjectConfiguration(Model model) {
        Map<String, Object> nxConfig = generateNxProjectConfigurationMap(model);
        System.out.println(mapToJson(nxConfig));
    }
    
    private static Map<String, Object> generateNxProjectConfigurationMap(Model model) {
        Map<String, Object> nxConfig = new LinkedHashMap<>();
        
        // Basic project information
        String projectName = model.getArtifactId();
        String projectType = "pom".equals(model.getPackaging()) ? "library" : "application";
        
        nxConfig.put("name", projectName);
        nxConfig.put("$schema", "../../node_modules/nx/schemas/project-schema.json");
        nxConfig.put("sourceRoot", "src/main/java");
        nxConfig.put("projectType", projectType);
        
        // Generate targets from Maven lifecycle phases and plugins
        Map<String, Object> targets = new LinkedHashMap<>();
        
        // Add standard Maven lifecycle targets
        addMavenLifecycleTargets(targets, model);
        
        // Add plugin-specific targets
        addPluginTargets(targets, model);
        
        nxConfig.put("targets", targets);
        
        // Add tags based on packaging and groupId
        List<String> tags = new ArrayList<>();
        if (model.getPackaging() != null) {
            tags.add("maven:" + model.getPackaging());
        }
        if (model.getGroupId() != null) {
            String[] groupParts = model.getGroupId().split("\\.");
            for (String part : groupParts) {
                tags.add("group:" + part);
            }
        }
        nxConfig.put("tags", tags);
        
        // Add all types of dependencies
        addProjectDependencies(nxConfig, model);
        
        return nxConfig;
    }
    
    private static void addMavenLifecycleTargets(Map<String, Object> targets, Model model) {
        String packaging = model.getPackaging() != null ? model.getPackaging() : "jar";
        
        // Common lifecycle phases as Nx targets
        addMavenTarget(targets, "validate", "mvn validate", "Validate the project is correct");
        addMavenTarget(targets, "compile", "mvn compile", "Compile the source code");
        addMavenTarget(targets, "test", "mvn test", "Run unit tests");
        addMavenTarget(targets, "package", "mvn package", "Create JAR/WAR package");
        addMavenTarget(targets, "verify", "mvn verify", "Run integration tests");
        addMavenTarget(targets, "install", "mvn install", "Install package to local repository");
        addMavenTarget(targets, "deploy", "mvn deploy", "Deploy package to remote repository");
        
        // Add packaging-specific targets
        if (!"pom".equals(packaging)) {
            addMavenTarget(targets, "clean", "mvn clean", "Clean the build directory");
            addMavenTarget(targets, "test-compile", "mvn test-compile", "Compile test sources");
        }
    }
    
    private static void addPluginTargets(Map<String, Object> targets, Model model) {
        if (model.getBuild() != null && model.getBuild().getPlugins() != null) {
            for (Plugin plugin : model.getBuild().getPlugins()) {
                String artifactId = plugin.getArtifactId();
                
                // Add common plugin targets
                if ("maven-surefire-plugin".equals(artifactId)) {
                    addMavenTarget(targets, "test-unit", "mvn surefire:test", "Run unit tests with Surefire");
                } else if ("maven-failsafe-plugin".equals(artifactId)) {
                    addMavenTarget(targets, "test-integration", "mvn failsafe:integration-test", "Run integration tests");
                } else if ("maven-compiler-plugin".equals(artifactId)) {
                    addMavenTarget(targets, "compile-main", "mvn compiler:compile", "Compile main sources");
                    addMavenTarget(targets, "compile-test", "mvn compiler:testCompile", "Compile test sources");
                } else if ("exec-maven-plugin".equals(artifactId)) {
                    addMavenTarget(targets, "exec", "mvn exec:java", "Execute main class");
                } else if ("spring-boot-maven-plugin".equals(artifactId)) {
                    addMavenTarget(targets, "serve", "mvn spring-boot:run", "Start Spring Boot application");
                } else if ("quarkus-maven-plugin".equals(artifactId)) {
                    addMavenTarget(targets, "serve", "mvn quarkus:dev", "Start Quarkus dev mode");
                    addMavenTarget(targets, "build-native", "mvn clean package -Pnative", "Build native executable");
                }
                
                // Add custom executions as targets
                if (plugin.getExecutions() != null) {
                    for (PluginExecution execution : plugin.getExecutions()) {
                        String executionId = execution.getId();
                        if (executionId != null && !"default".equals(executionId)) {
                            String targetName = artifactId.replace("-maven-plugin", "") + "-" + executionId;
                            String command = "mvn " + plugin.getGroupId() + ":" + artifactId + ":" + executionId;
                            addMavenTarget(targets, targetName, command, "Run " + executionId + " execution");
                        }
                    }
                }
            }
        }
    }
    
    private static void addMavenTarget(Map<String, Object> targets, String name, String command, String description) {
        Map<String, Object> target = new LinkedHashMap<>();
        target.put("executor", "nx:run-commands");
        
        Map<String, Object> options = new LinkedHashMap<>();
        options.put("command", command);
        if (description != null) {
            options.put("description", description);
        }
        target.put("options", options);
        
        targets.put(name, target);
    }
    
    private static void printJson(Object obj, int indent) {
        String indentStr = "  ".repeat(indent);
        
        if (obj instanceof Map) {
            Map<?, ?> map = (Map<?, ?>) obj;
            System.out.println("{");
            
            Object[] keys = map.keySet().toArray();
            for (int i = 0; i < keys.length; i++) {
                Object key = keys[i];
                Object value = map.get(key);
                
                System.out.print(indentStr + "  \"" + key + "\": ");
                printJson(value, indent + 1);
                
                if (i < keys.length - 1) {
                    System.out.println(",");
                } else {
                    System.out.println();
                }
            }
            
            System.out.print(indentStr + "}");
        } else if (obj instanceof List) {
            List<?> list = (List<?>) obj;
            System.out.println("[");
            
            for (int i = 0; i < list.size(); i++) {
                System.out.print(indentStr + "  ");
                printJson(list.get(i), indent + 1);
                
                if (i < list.size() - 1) {
                    System.out.println(",");
                } else {
                    System.out.println();
                }
            }
            
            System.out.print(indentStr + "]");
        } else if (obj instanceof String) {
            System.out.print("\"" + obj + "\"");
        } else {
            System.out.print(obj);
        }
    }
    
    private static String mapToJson(Object obj) {
        StringBuilder sb = new StringBuilder();
        mapToJson(obj, 0, sb);
        return sb.toString();
    }
    
    private static void mapToJson(Object obj, int indent, StringBuilder sb) {
        String indentStr = "  ".repeat(indent);
        
        if (obj instanceof Map) {
            Map<?, ?> map = (Map<?, ?>) obj;
            sb.append("{\n");
            
            Object[] keys = map.keySet().toArray();
            for (int i = 0; i < keys.length; i++) {
                Object key = keys[i];
                Object value = map.get(key);
                
                sb.append(indentStr).append("  \"").append(key).append("\": ");
                mapToJson(value, indent + 1, sb);
                
                if (i < keys.length - 1) {
                    sb.append(",\n");
                } else {
                    sb.append("\n");
                }
            }
            
            sb.append(indentStr).append("}");
        } else if (obj instanceof List) {
            List<?> list = (List<?>) obj;
            sb.append("[\n");
            
            for (int i = 0; i < list.size(); i++) {
                sb.append(indentStr).append("  ");
                mapToJson(list.get(i), indent + 1, sb);
                
                if (i < list.size() - 1) {
                    sb.append(",\n");
                } else {
                    sb.append("\n");
                }
            }
            
            sb.append(indentStr).append("]");
        } else if (obj instanceof String) {
            sb.append("\"").append(obj).append("\"");
        } else {
            sb.append(obj);
        }
    }
    
    private static void addProjectDependencies(Map<String, Object> nxConfig, Model model) {
        // 1. implicitDependencies - Manual project dependencies
        Map<String, Object> implicitDependencies = generateImplicitDependencies(model);
        if (!implicitDependencies.isEmpty()) {
            nxConfig.put("implicitDependencies", implicitDependencies);
        }
        
        // 2. namedInputs - Cache input definitions
        Map<String, Object> namedInputs = generateNamedInputs(model);
        if (!namedInputs.isEmpty()) {
            nxConfig.put("namedInputs", namedInputs);
        }
        
        // 3. Update targets with dependsOn and inputs
        @SuppressWarnings("unchecked")
        Map<String, Object> targets = (Map<String, Object>) nxConfig.get("targets");
        if (targets != null) {
            addTargetDependencies(targets, model);
        }
    }
    
    private static Map<String, Object> generateImplicitDependencies(Model model) {
        Map<String, Object> implicitDeps = new LinkedHashMap<>();
        
        // Analyze Maven dependencies
        if (model.getDependencies() != null && !model.getDependencies().isEmpty()) {
            List<String> projectDeps = new ArrayList<>();
            List<String> externalDeps = new ArrayList<>();
            
            System.err.println("DEBUG: Analyzing " + model.getDependencies().size() + " dependencies for " + model.getArtifactId());
            
            for (Dependency dep : model.getDependencies()) {
                String depKey = dep.getGroupId() + ":" + dep.getArtifactId();
                
                // Check if this might be an internal project dependency
                if (isInternalDependency(dep, model)) {
                    projectDeps.add(dep.getArtifactId()); // Use artifactId as project name
                    System.err.println("DEBUG: Found internal dependency: " + depKey);
                } else {
                    // External dependency - include for reference
                    String depInfo = depKey;
                    if (dep.getVersion() != null) {
                        depInfo += ":" + dep.getVersion();
                    }
                    if (dep.getScope() != null && !"compile".equals(dep.getScope())) {
                        depInfo += " (" + dep.getScope() + ")";
                    }
                    externalDeps.add(depInfo);
                }
            }
            
            // Add project dependencies (for Nx graph)
            if (!projectDeps.isEmpty()) {
                implicitDeps.put("projects", projectDeps);
            }
            
            // Add external dependencies as metadata
            if (!externalDeps.isEmpty()) {
                implicitDeps.put("external", externalDeps);
            }
        }
        
        // Analyze parent relationship
        if (model.getParent() != null) {
            List<String> parentDeps = new ArrayList<>();
            parentDeps.add(model.getParent().getArtifactId());
            implicitDeps.put("inheritsFrom", parentDeps);
        }
        
        return implicitDeps;
    }
    
    private static Map<String, Object> generateNamedInputs(Model model) {
        Map<String, Object> namedInputs = new LinkedHashMap<>();
        
        // Default inputs for Maven projects
        List<String> defaultInputs = new ArrayList<>();
        defaultInputs.add("{projectRoot}/**/*");
        defaultInputs.add("!{projectRoot}/target/**/*"); // Exclude build output
        namedInputs.put("default", defaultInputs);
        
        // Production inputs (excluding test files)
        List<String> productionInputs = new ArrayList<>();
        productionInputs.add("default");
        productionInputs.add("!{projectRoot}/src/test/**/*");
        productionInputs.add("!{projectRoot}/**/*.test.java");
        productionInputs.add("!{projectRoot}/**/*Test.java");
        productionInputs.add("!{projectRoot}/**/*Tests.java");
        namedInputs.put("production", productionInputs);
        
        // Test inputs
        List<String> testInputs = new ArrayList<>();
        testInputs.add("default");
        testInputs.add("{projectRoot}/src/test/**/*");
        namedInputs.put("test", testInputs);
        
        // Add project-specific inputs based on dependencies
        if (model.getDependencies() != null) {
            for (Dependency dep : model.getDependencies()) {
                if (isInternalDependency(dep, model)) {
                    // Add dependency outputs as inputs
                    List<String> depInputs = new ArrayList<>();
                    depInputs.add("^production");
                    namedInputs.put("withDependencies", depInputs);
                    break;
                }
            }
        }
        
        return namedInputs;
    }
    
    private static void addTargetDependencies(Map<String, Object> targets, Model model) {
        // Add dependsOn and inputs to existing targets
        for (Map.Entry<String, Object> entry : targets.entrySet()) {
            String targetName = entry.getKey();
            @SuppressWarnings("unchecked")
            Map<String, Object> target = (Map<String, Object>) entry.getValue();
            
            // Add inputs based on target type
            List<String> inputs = getInputsForTarget(targetName, model);
            if (!inputs.isEmpty()) {
                target.put("inputs", inputs);
            }
            
            // Add dependsOn based on target type
            List<String> dependsOn = getDependsOnForTarget(targetName, model);
            if (!dependsOn.isEmpty()) {
                target.put("dependsOn", dependsOn);
            }
            
            // Add outputs for build targets
            List<String> outputs = getOutputsForTarget(targetName, model);
            if (!outputs.isEmpty()) {
                target.put("outputs", outputs);
            }
        }
    }
    
    private static List<String> getInputsForTarget(String targetName, Model model) {
        List<String> inputs = new ArrayList<>();
        
        switch (targetName) {
            case "compile":
            case "compile-main":
                inputs.add("production");
                inputs.add("^production");
                break;
            case "test":
            case "test-compile":
                inputs.add("test");
                inputs.add("^production");
                break;
            case "package":
            case "install":
            case "deploy":
                inputs.add("production");
                inputs.add("^production");
                break;
            case "clean":
                inputs.add("{projectRoot}/target/**/*");
                break;
            default:
                inputs.add("default");
                break;
        }
        
        return inputs;
    }
    
    private static List<String> getDependsOnForTarget(String targetName, Model model) {
        List<String> dependsOn = new ArrayList<>();
        
        // Check if project has internal dependencies
        boolean hasInternalDeps = false;
        if (model.getDependencies() != null) {
            for (Dependency dep : model.getDependencies()) {
                if (isInternalDependency(dep, model)) {
                    hasInternalDeps = true;
                    break;
                }
            }
        }
        
        if (hasInternalDeps) {
            switch (targetName) {
                case "compile":
                case "compile-main":
                    dependsOn.add("^compile");
                    break;
                case "test":
                    dependsOn.add("^compile");
                    dependsOn.add("compile");
                    break;
                case "package":
                    dependsOn.add("^package");
                    dependsOn.add("compile");
                    break;
                case "install":
                    dependsOn.add("^install");
                    dependsOn.add("package");
                    break;
                case "deploy":
                    dependsOn.add("^deploy");
                    dependsOn.add("package");
                    break;
            }
        } else {
            // No internal dependencies, simpler dependsOn
            switch (targetName) {
                case "test":
                    dependsOn.add("compile");
                    break;
                case "package":
                    dependsOn.add("compile");
                    break;
                case "install":
                    dependsOn.add("package");
                    break;
                case "deploy":
                    dependsOn.add("package");
                    break;
            }
        }
        
        return dependsOn;
    }
    
    private static List<String> getOutputsForTarget(String targetName, Model model) {
        List<String> outputs = new ArrayList<>();
        
        switch (targetName) {
            case "compile":
            case "compile-main":
                outputs.add("{projectRoot}/target/classes");
                break;
            case "test-compile":
                outputs.add("{projectRoot}/target/test-classes");
                break;
            case "package":
                String packaging = model.getPackaging() != null ? model.getPackaging() : "jar";
                outputs.add("{projectRoot}/target/*." + packaging);
                break;
            case "test":
                outputs.add("{projectRoot}/target/surefire-reports");
                outputs.add("{projectRoot}/target/site/jacoco");
                break;
        }
        
        return outputs;
    }
    
    private static boolean isInternalDependency(Dependency dep, Model model) {
        // Consider it internal if:
        // 1. Same groupId as the current project
        if (model.getGroupId() != null && model.getGroupId().equals(dep.getGroupId())) {
            return true;
        }
        
        // 2. GroupId starts with same organization prefix (first 2 parts)
        if (model.getGroupId() != null && dep.getGroupId() != null) {
            String[] modelParts = model.getGroupId().split("\\.");
            String[] depParts = dep.getGroupId().split("\\.");
            
            if (modelParts.length >= 2 && depParts.length >= 2) {
                return modelParts[0].equals(depParts[0]) && modelParts[1].equals(depParts[1]);
            }
        }
        
        // 3. Common internal dependency patterns
        if (dep.getGroupId() != null) {
            String groupId = dep.getGroupId();
            // Add patterns for internal dependencies
            return groupId.startsWith("com.yourcompany") || 
                   groupId.startsWith("org.yourorg") ||
                   groupId.startsWith("io.quarkus") ||  // Quarkus internal deps
                   groupId.contains("internal") ||
                   groupId.contains("${project.groupId}");
        }
        
        return false;
    }
    
    private static void analyzeLifecycleBindings(Model model) {
        System.out.println("=== Plugin Analysis ===");
        
        Map<String, String> phaseBindings = new TreeMap<>();
        
        if (model.getBuild() != null && model.getBuild().getPlugins() != null) {
            for (Plugin plugin : model.getBuild().getPlugins()) {
                String pluginKey = plugin.getGroupId() + ":" + plugin.getArtifactId() + 
                    (plugin.getVersion() != null ? ":" + plugin.getVersion() : "");
                
                System.out.println("Plugin: " + pluginKey);
                
                // Show all goals for this plugin (if executions are defined)
                if (plugin.getExecutions() != null && !plugin.getExecutions().isEmpty()) {
                    for (PluginExecution execution : plugin.getExecutions()) {
                        String phase = execution.getPhase();
                        String executionId = execution.getId() != null ? execution.getId() : "default";
                        List<String> goals = execution.getGoals();
                        
                        System.out.println("  Execution '" + executionId + "':");
                        System.out.println("    Phase: " + (phase != null ? phase : "default binding"));
                        System.out.println("    Goals: " + goals);
                        
                        // Track phase bindings for summary
                        if (phase != null) {
                            for (String goal : goals) {
                                String binding = pluginKey + ":" + goal;
                                phaseBindings.put(phase, phaseBindings.getOrDefault(phase, "") + 
                                    (phaseBindings.containsKey(phase) ? ", " : "") + binding);
                            }
                        }
                    }
                } else {
                    System.out.println("  No explicit executions (uses default plugin goal bindings)");
                }
                
                // Show configuration if present
                if (plugin.getConfiguration() != null) {
                    System.out.println("  Configuration: " + plugin.getConfiguration().toString());
                }
                System.out.println();
            }
        }
        
        System.out.println("=== Lifecycle Phase Bindings ===");
        if (phaseBindings.isEmpty()) {
            System.out.println("No explicit phase bindings found (using default lifecycle)");
            printDefaultLifecycle(model.getPackaging());
        } else {
            System.out.println("Explicit phase bindings:");
            for (Map.Entry<String, String> entry : phaseBindings.entrySet()) {
                System.out.println("* " + entry.getKey() + ": " + entry.getValue());
            }
            System.out.println("\nNote: Other phases use default bindings for '" + 
                (model.getPackaging() != null ? model.getPackaging() : "jar") + "' packaging");
        }
    }
    
    private static void printDefaultLifecycle(String packaging) {
        System.out.println("\nDefault lifecycle for packaging '" + (packaging != null ? packaging : "jar") + "':");
        
        if ("pom".equals(packaging)) {
            System.out.println("* validate: Not defined");
            System.out.println("* initialize: Not defined");
            System.out.println("* generate-sources: Not defined");
            System.out.println("* process-sources: Not defined");
            System.out.println("* generate-resources: Not defined");
            System.out.println("* process-resources: Not defined");
            System.out.println("* compile: Not defined");
            System.out.println("* process-classes: Not defined");
            System.out.println("* generate-test-sources: Not defined");
            System.out.println("* process-test-sources: Not defined");
            System.out.println("* generate-test-resources: Not defined");
            System.out.println("* process-test-resources: Not defined");
            System.out.println("* test-compile: Not defined");
            System.out.println("* process-test-classes: Not defined");
            System.out.println("* test: Not defined");
            System.out.println("* prepare-package: Not defined");
            System.out.println("* package: Not defined");
            System.out.println("* install: maven-install-plugin:install");
            System.out.println("* deploy: maven-deploy-plugin:deploy");
        } else {
            // Default jar packaging
            System.out.println("* validate: Not defined");
            System.out.println("* initialize: Not defined");
            System.out.println("* generate-sources: Not defined");
            System.out.println("* process-sources: Not defined");
            System.out.println("* generate-resources: Not defined");
            System.out.println("* process-resources: maven-resources-plugin:resources");
            System.out.println("* compile: maven-compiler-plugin:compile");
            System.out.println("* process-classes: Not defined");
            System.out.println("* generate-test-sources: Not defined");
            System.out.println("* process-test-sources: Not defined");
            System.out.println("* generate-test-resources: Not defined");
            System.out.println("* process-test-resources: maven-resources-plugin:testResources");
            System.out.println("* test-compile: maven-compiler-plugin:testCompile");
            System.out.println("* process-test-classes: Not defined");
            System.out.println("* test: maven-surefire-plugin:test");
            System.out.println("* prepare-package: Not defined");
            System.out.println("* package: maven-jar-plugin:jar");
            System.out.println("* install: maven-install-plugin:install");
            System.out.println("* deploy: maven-deploy-plugin:deploy");
        }
    }
}
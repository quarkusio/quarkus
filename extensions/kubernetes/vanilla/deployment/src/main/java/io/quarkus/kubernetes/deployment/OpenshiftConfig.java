
package io.quarkus.kubernetes.deployment;

import static io.quarkus.kubernetes.deployment.Constants.BATCH_GROUP;
import static io.quarkus.kubernetes.deployment.Constants.BATCH_VERSION;
import static io.quarkus.kubernetes.deployment.Constants.CRONJOB;
import static io.quarkus.kubernetes.deployment.Constants.DEPLOYMENT;
import static io.quarkus.kubernetes.deployment.Constants.DEPLOYMENT_CONFIG;
import static io.quarkus.kubernetes.deployment.Constants.DEPLOYMENT_CONFIG_GROUP;
import static io.quarkus.kubernetes.deployment.Constants.DEPLOYMENT_CONFIG_VERSION;
import static io.quarkus.kubernetes.deployment.Constants.DEPLOYMENT_GROUP;
import static io.quarkus.kubernetes.deployment.Constants.DEPLOYMENT_VERSION;
import static io.quarkus.kubernetes.deployment.Constants.JOB;
import static io.quarkus.kubernetes.deployment.Constants.OPENSHIFT;
import static io.quarkus.kubernetes.deployment.Constants.S2I;
import static io.quarkus.kubernetes.deployment.Constants.STATEFULSET;

import java.util.Map;
import java.util.Optional;
import java.util.OptionalInt;

import io.quarkus.container.image.deployment.ContainerImageCapabilitiesUtil;
import io.quarkus.container.image.deployment.ContainerImageConfig;
import io.quarkus.deployment.Capabilities;
import io.quarkus.deployment.Capability;
import io.quarkus.kubernetes.spi.DeployStrategy;
import io.quarkus.runtime.annotations.ConfigItem;
import io.quarkus.runtime.annotations.ConfigRoot;

@ConfigRoot
public class OpenshiftConfig extends KubernetesCommonConfig {

    public static enum OpenshiftFlavor {
        v3,
        v4;
    }

    public static enum DeploymentResourceKind {
        Deployment(DEPLOYMENT, DEPLOYMENT_GROUP, DEPLOYMENT_VERSION),
        DeploymentConfig(DEPLOYMENT_CONFIG, DEPLOYMENT_CONFIG_GROUP, DEPLOYMENT_CONFIG_VERSION),
        StatefulSet(STATEFULSET, DEPLOYMENT_GROUP, DEPLOYMENT_VERSION),
        Job(JOB, BATCH_GROUP, BATCH_VERSION),
        CronJob(CRONJOB, BATCH_GROUP, BATCH_VERSION);

        public final String kind;
        public final String apiGroup;
        public final String apiVersion;

        DeploymentResourceKind(String kind, String apiGroup, String apiVersion) {
            this.kind = kind;
            this.apiGroup = apiGroup;
            this.apiVersion = apiVersion;
        }
    }

    /**
     * The OpenShift flavor / version to use.
     * Older versions of OpenShift have minor differences in the labels and fields they support.
     * This option allows users to have their manifests automatically aligned to the OpenShift 'flavor' they use.
     */
    @ConfigItem(defaultValue = "v4")
    OpenshiftFlavor flavor;

    /**
     * The kind of the deployment resource to use.
     * Supported values are 'Deployment', 'StatefulSet', 'Job', 'CronJob' and 'DeploymentConfig' defaulting to the latter.
     */
    @ConfigItem
    Optional<DeploymentResourceKind> deploymentKind;

    /**
     * The number of desired pods
     */
    @ConfigItem(defaultValue = "1")
    Integer replicas;

    /**
     * The nodePort to set when serviceType is set to nodePort
     */
    @ConfigItem
    OptionalInt nodePort;

    /**
     * Openshift route configuration
     */
    RouteConfig route;

    /**
     * Job configuration. It's only used if and only if {@code quarkus.openshift.deployment-kind} is `Job`.
     */
    JobConfig job;

    /**
     * CronJob configuration. It's only used if and only if {@code quarkus.openshift.deployment-kind} is `CronJob`.
     */
    CronJobConfig cronJob;

    public Integer getReplicas() {
        return replicas;
    }

    @Override
    public String getTargetPlatformName() {
        return Constants.OPENSHIFT;
    }

    /**
     * Debug configuration to be set in pods.
     */
    DebugConfig remoteDebug;

    /**
     * If set to true, Quarkus will attempt to deploy the application to the target Openshift cluster
     */
    @ConfigItem(defaultValue = "false")
    boolean deploy;

    /**
     * If deploy is enabled, it will follow this strategy to update the resources to the target OpenShift cluster.
     */
    @ConfigItem(defaultValue = "CreateOrUpdate")
    DeployStrategy deployStrategy;

    /**
     * Flag to enable init task externalization.
     * When enabled (default), all initialization tasks
     * created by extensions, will be externalized as Jobs.
     * In addition, the deployment will wait for these jobs.
     *
     * @Deprecated use {@link #initTasks} configuration instead
     */
    @Deprecated(since = "3.1", forRemoval = true)
    @ConfigItem(defaultValue = "true")
    boolean externalizeInit;

    /**
     * Init tasks configuration.
     *
     * The init tasks are automatically generated by extensions like Flyway to perform the database migration before staring
     * up the application.
     *
     * This property is only taken into account if `quarkus.openshift.externalize-init` is true.
     */
    @ConfigItem
    Map<String, InitTaskConfig> initTasks;

    public DeployStrategy getDeployStrategy() {
        return deployStrategy;
    }

    public static boolean isOpenshiftBuildEnabled(ContainerImageConfig containerImageConfig, Capabilities capabilities) {
        boolean implicitlyEnabled = ContainerImageCapabilitiesUtil.getActiveContainerImageCapability(capabilities)
                .filter(c -> c.contains(OPENSHIFT) || c.contains(S2I)).isPresent();
        return containerImageConfig.builder.map(b -> b.equals(OPENSHIFT) || b.equals(S2I)).orElse(implicitlyEnabled);
    }

    public DeploymentResourceKind getDeploymentResourceKind(Capabilities capabilities) {
        if (deploymentKind.isPresent()) {
            return deploymentKind.get();
        } else if (capabilities.isPresent(Capability.PICOCLI)) {
            return DeploymentResourceKind.Job;
        }

        return DeploymentResourceKind.DeploymentConfig;
    }
}

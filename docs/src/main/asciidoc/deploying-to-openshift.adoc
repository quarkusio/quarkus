////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
[id="deploy-openshift"]
= Deploy Quarkus applications on OpenShift Container Platform
include::_attributes.adoc[]
:diataxis-type: howto
:categories: cloud, native

Deploy your Quarkus applications to OpenShift Container Platform by using the `quarkus-openshift` extension.

Quarkus supports multiple build strategies and deployment options.
For information about build and deployment options, see xref:deployment-to-openshift.adoc[Quarkus deployment to OpenShift].

== Prerequisites

:prerequisites-no-graalvm:
include::{includes}/prerequisites.adoc[]
* Access to an OpenShift Container Platform cluster and the latest compatible version of the `oc` tool installed (Minishift is a viable option)
* Access to the link:https://docs.openshift.com/container-platform/4.9/cli_reference/openshift_cli/getting-started-cli.html[OpenShift CLI] (Optional, only required for manual deployment)
* Mandrel or GraalVM installed and configured appropriately.
For more information, see link:https://quarkus.io/guides/building-native-image#configuring-graalvm[Configuring GraalVM].

:sectnums:
:sectnumlevels: 3

== Create a new project that includes the Quarkus OpenShift extension

Create a new project that includes the `quarkus-openshift` extension.
To build and deploy your applications as a container image that runs inside your OpenShift Container Platform cluster, add the Quarkus OpenShift extension as a dependency to your project.
Run the following command:

:create-app-artifact-id: openshift-quickstart
:create-app-extensions: resteasy-reactive,openshift
:create-app-code:
include::{includes}/devtools/create-app.adoc[]

By using Quarkus, you can automatically generate OpenShift resources based on sane defaults and user-supplied configuration.
The OpenShift extension is a wrapper extension that brings together the xref:deploying-to-kubernetes.adoc[kubernetes] and xref:container-image.adoc#openshift[container-image-openshift] extensions with sensible defaults, which helps you to get started with Quarkus on OpenShift.

When you add the OpenShift extension, you add the following dependency to the `pom.xml` or `build.gradle` files.

[source,xml,role="primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven"]
.pom.xml
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-openshift</artifactId>
</dependency>
----

[source,gradle,role="secondary asciidoc-tabs-target-sync-gradle"]
.build.gradle
----
implementation("io.quarkus:quarkus-openshift")
----

== Log in to the OpenShift cluster

Before you build and deploy your Quarkus application, you must log in to an OpenShift cluster.

* To log in by using the link:https://docs.openshift.com/container-platform/4.9/cli_reference/openshift_cli/getting-started-cli.html[OpenShift CLI], enter the following command:
+
.Example: Log in by using the OpenShift CLI
[source,bash]
----
oc login -u myUsername <1>
----
<1> You will be prompted for required information, such as server URL and password.

* Alternatively, you can log in by using an API token:
+
.Example: Log in by using the OpenShift CLI and the API token
[source,bash]
----
oc login --token=myToken --server=myServerUrl
----
+
[TIP]
====
You can request the token by using the _Copy Login Command_ link in the OpenShift web console.
====

* Alternatively, you can set the `quarkus.kubernetes-client.api-server-url` configuration property.
Then, authenticate by using the `quarkus.kubernetes-client.token`, or `quarkus.kubernetes-client.username` and `quarkus.kubernetes-client.password` properties respectively.

:build-additional-parameters: -Dquarkus.kubernetes-client.api-server-url=myServerUrl -Dquarkus.kubernetes-client.token=myToken
include::{includes}/devtools/build.adoc[]
:!build-additional-parameters:

== Choose how you want to build and deploy your Quarkus application

You can build and deploy your Quarkus application to OpenShift Container Platform in a single step.
Alternatively, you can build the container image first and then configure the OpenShift application manually if you want more control over the deployment configuration.

For information about other deployment options, see
* xref:deploying-native-executable-openshift.adoc[Deploy your Quarkus applications compiled to native executables].
* xref:deploying-to-openshift-serveless.adoc[Deploy Quarkus applications as an OpenShift Serverless service].

=== Option: Build and deploy in a single step
To trigger a build and deployment in a single step, run the following command:

:build-additional-parameters: -Dquarkus.kubernetes.deploy=true
include::{includes}/devtools/build.adoc[]
:!build-additional-parameters:

By running this command, you build your application locally, trigger a container image build, and finally, apply the generated OpenShift resources automatically.
The generated resources use OpenShift's `DeploymentConfig` that is configured to automatically trigger a redeployment when a change in the `ImageStream` is noticed.
That is, any container image build after the initial deployment automatically triggers redeployment, without having to delete, update, or reapply the generated resources.

[TIP]
====
If you want to test your application immediately, set the `quarkus.openshift.route.expose` configuration property to `true` to <<exposing_routes,expose the service automatically>>.
For example, add `-Dquarkus.openshift.route.expose=true` to the command.
====

[#re-deploy-with-service-binding]
[NOTE]
====
When you use `DeploymentConfig` and link:https://quarkus.io/guides/deploying-to-kubernetes#service_binding[Service Binding], re-deploying might remove the configuration that is added by OpenShift to allow service discovery.

A new container image build triggers a refresh of the Quarkus application in OpenShift, `-Dquarkus.container-image.build=true`, which might suffice in most situations.
If you must update the OpenShift resources, you first delete the binding to create it again after a new deployment.
====

To verify that the above command created an image stream and a service resource and has deployed the application, use the OpenShift web console.
Alternatively, you can run the following OpenShift CLI commands:
[source,bash,subs=attributes+]
----
oc get is <1>
oc get pods <2>
oc get svc <3>
----
<1> List the image streams created.
<2> View a list of pods associated with your current OpenShift project.
<3> Get the list of Kubernetes services.

The service is not exposed to the outside world by default.
Therefore, unless you have used the `quarkus.openshift.route.expose` configuration property to expose the created service automatically, you must expose the service manually.

.Example: Expose the service by using the OpenShift CLI
[source,bash,subs=attributes+]
----
oc expose svc/openshift-quickstart <1>
oc get routes <2>
curl http://<route>/hello <3>
----
<1> Expose the service.
<2> Get the list of exposed routes.
<3> Access your application.

[[control_application_config]]

=== Option: Build image and configure OpenShift application manually

If you want more control over the deployment configuration, you can build the container image first and then configure the OpenShift application manually.

To trigger a container image build:

[source,bash,subs=attributes+]
----
./mvnw clean package -Dquarkus.container-image.build=true
----

An OpenShift binary build is performed.
The build input is the JAR file that was built locally.
The build output is an `ImageStream` that is configured to automatically trigger a deployment.

[NOTE]
====
During the build, you might find the `Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path building failed` exception occurred due to self-signed certificate.
To solve this, add the following line to your `application.properties` file:

[source,properties]
----
quarkus.kubernetes-client.trust-certs=true
----

For more information, see the link:https://quarkus.io/guides/deploying-to-kubernetes#client-connection-configuration[Client connection configuraton] section of the "Kubernetes extension" guide.
====

When the build finishes, create a new application from the relevant `ImageStream`.
Run the following commands:

[source,bash,subs=attributes+]
----
oc get is <1>
oc new-app --name=greeting <project>/openshift-quickstart:1.0.0-SNAPSHOT <2>
oc get svc
oc expose svc/greeting <3>
oc get routes <4>
curl http://<route>/hello <5>
----
<1> Lists the image streams created.
The image stream of the application should be tagged as <project>/openshift-quickstart:1.0.0-SNAPSHOT.
<2> Create a new application from the image source.
<3> Expose the service to the outside world.
<4> Get the list of exposed routes.
<5> Access your application.

After this setup, the next time you build a container image, a deployment to OpenShift is triggered automatically so you do not need to repeat the above steps.

=== Option: Configure OpenShift application manually by using the Docker build

Build and deploy your Quarkus application to OpenShift Container Platform by using the Docker build strategy.

. Set the Docker build strategy in your `application.properties` configuration file:
+
[source, properties]
----
quarkus.openshift.build-strategy=docker
----
. (Optional): Set the following properties in the `application.properties` file, as required by your environment:
.. If you are using an untrusted certificate, configure the `KubernetesClient`:
+
[source,properties]
----
quarkus.kubernetes-client.trust-certs=true
----
.. Expose the service to create an OpenShift Container Platform route:
+
[source,properties]
----
quarkus.openshift.route.expose=true
----
.. Set the path to your custom Dockerfile:
+
[source,properties,subs="attributes+,+quotes"]
----
quarkus.openshift.jvm-dockerfile=<path_to_your_dockerfile>
----
The following example shows the path to the `Dockerfile.custom-jvm`:
+
[source,properties]
----
quarkus.openshift.jvm-dockerfile=src/main/resources/Dockerfile.custom-jvm
----
. Package and deploy your Quarkus application to the current OpenShift project:
+
[source,shell,subs="attributes+,+quotes"]
----
./mvnw clean package -Dquarkus.kubernetes.deploy=true
----

When the build finishes, verify your deployment.
Run the following commands:

[source,bash,subs=attributes+]
----
oc get pods <1>
oc logs -f <pod_name> <2>
oc get svc <3>
oc get routes <4>
curl http://<route>/hello <5>
----

<1> View a list of pods associated with your current OpenShift project.
<2> Retrieve the log output for your application’s pod, where <pod_name> is the name of the latest pod prefixed with the name of your application.
<3> Get the list of Kubernetes services.
<4> Get a URL to test your application.
<5> Access your application.

=== Option: Configure non-OpenShift container image build

As an out-of-the-box feature, the OpenShift extension is configured to use the `quarkus-container-image-openshift` extension to build the container image inside the OpenShift cluster.
For information about the OpenShift container image, see xref:container-image.adoc#openshift[container-image-openshift].

However, you can use other container image extensions.
For example:

- xref:container-image.adoc#docker[container-image-docker]
- xref:container-image.adoc#jib[container-image-jib]

When you use a non-OpenShift container image extension, an `ImageStream` is created that points to an external `dockerImageRepository`.
The image is built and pushed to the registry and the `ImageStream` populates the tags that are available in the `dockerImageRepository`.

Select the extension you want to use to build the image, by choosing one of the following commands.

* To use the `quarkus-container-image-docker` extenstion, run the following command:
+
[source,properties]
----
quarkus.container-image.builder=docker
----

* To use the `quarkus-container-image-jib` extension, run the following command:
+
[source,properties]
----
quarkus.container-image.builder=jib
----

To view other deployment options, see the following guides:

* xref:deploying-native-executable-openshift.adoc[Deploy a Quarkus native application on OpenShift]
* xref:deploying-to-openshift-serverless.adoc[Deploy Quarkus applications as an OpenShift Serverless service]

== Customize your deployment

For a list of available customization options, see xref:deploying-to-kubernetes.adoc#openshift[OpenShift configuration options].

Some examples are provided in the sections below:

[[exposing_routes]]
=== Expose routes

To expose a `Route` for the Quarkus application, run the following command:

[source,properties]
----
quarkus.openshift.route.expose=true
----

[TIP]
====

You do not need add this property in the `application.properties` file.
Instead, you pass it as a command-line argument:

[source,bash,subs=attributes+]
----
./mvnw clean package -Dquarkus.openshift.route.expose=true
----

The same applies to all properties listed below.
====

==== Secure the Route resource

To secure incoming connections, OpenShift provides several types of TLS termination to serve certifications.
For more information about how to secure routes, see the link:https://docs.openshift.com/container-platform/4.12/networking/routes/secured-routes.html[Secured routes] section in the "OpenShift Container Platform" documentation.

.Example: Configure a secured Route using passthrough termination by adding the "quarkus.openshift.route.tls" properties:

[source,properties]
----
quarkus.openshift.route.expose=true
quarkus.openshift.route.target-port=https
## Route TLS configuration:
quarkus.openshift.route.tls.termination=passthrough
quarkus.openshift.route.tls.insecure-edge-termination-policy=None
----

=== Add labels

To add a label in the generated resources, run the following command:

[source,properties]
----
quarkus.openshift.labels.foo=bar
----

=== Add annotations

To add an annotation in the generated resources, run the following command:

[source,properties]
----
quarkus.openshift.annotations.foo=bar
----

[#env-vars]
=== Define environment variables

OpenShift provides multiple ways of defining environment variables.
For example:

- Use key/value pairs
- Import all values from a Secret or ConfigMap
- Interpolate a single value identified by a given field in a Secret or ConfigMap
- Interpolate a value from a field within the same resource

==== Environment variables from key-value pairs

To add a key-value pair as an environment variable in the generated resources, run the following command:

[source,properties]
----
quarkus.openshift.env.vars.my-env-var=foobar
----

By using this command, you add `MY_ENV_VAR=foobar` as an environment variable.
The key `my-env-var` is converted to uppercase and dashes are replaced by underscores, resulting in `MY_ENV_VAR`.

==== Environment variables from Secret

To add all key-value pairs of `Secret` as environment variables, specify the following configuration, by using a comma-separated list to separate each `Secret` you use as a source:

[source,properties]
----
quarkus.openshift.env.secrets=my-secret,my-other-secret
----

This configuration generates the following output in the container definition:

[source,yaml]
----
envFrom:
  - secretRef:
      name: my-secret
      optional: false
  - secretRef:
      name: my-other-secret
      optional: false
----

The following configuration extracts a value identified by the `keyName` field from the `my-secret` Secret into a `foo` environment variable:

[source,properties]
----
quarkus.openshift.env.mapping.foo.from-secret=my-secret
quarkus.openshift.env.mapping.foo.with-key=keyName
----

This configuration generates the following in the `env` section of your container:

[source,yaml]
----
- env:
  - name: FOO
    valueFrom:
      secretKeyRef:
        key: keyName
        name: my-secret
        optional: false
----

==== Environment variables from ConfigMap

To add all key-value pairs from `ConfigMap` as environment variables, specify the following configuration, using a comma-separated list to separate each `ConfigMap` you use as a source:

[source,properties]
----
quarkus.openshift.env.configmaps=my-config-map,another-config-map
----

This configuration generates the following output in the container definition:

[source,yaml]
----
envFrom:
  - configMapRef:
      name: my-config-map
      optional: false
  - configMapRef:
      name: another-config-map
      optional: false
----

The following configuration extracts a value identified by the `keyName` field from the `my-config-map` ConfigMap into a `foo` environment variable:

[source,properties]
----
quarkus.openshift.env.mapping.foo.from-configmap=my-configmap
quarkus.openshift.env.mapping.foo.with-key=keyName
----

This configuration generates the following in the `env` section of your container:

[source,yaml]
----
- env:
  - name: FOO
    valueFrom:
      configMapRefKey:
        key: keyName
        name: my-configmap
        optional: false
----

==== Environment variables from fields

You can also use the value from another field to add a new environment variable by specifying the path of the field to use as a source.
For example:

[source,properties]
----
quarkus.openshift.env.fields.foo=metadata.name
----

==== Change the generated deployment resource

In addition to generating a `DeploymentConfig` resource, you can also choose to get either a `Deployment`, `StatefulSet`, or a `Job` or a `CronJob` resource instead by using `application.properties`:

[source,properties]
----
quarkus.openshift.deployment-kind=StatefulSet
----

* Use Deployment resource instead of DeploymentConfig
+
As an out-of-the-box feature, the `quarkus-extension` generates a `DeploymentConfig` resource.
However, you might prefer to use `Deployment` as the main deployment resource, but still make use of OpenShift-specific resources, such as `Route`, `BuildConfig`, and so on.
+
Enable the `Deployment` feature by setting the `quarkus.openshift.deployment-kind` property to `Deployment`.
+
.Example

[source,properties]
----
quarkus.openshift.deployment-kind=Deployment
----
+
As `Deployment` is a Kubernetes resource and not OpenShift specific, it cannot leverage `ImageStream` resources, as is the case with `DeploymentConfig`.
This means that the image references must include the container image registry that hosts the image.
When the image is built, using OpenShift builds (S2I binary and Docker strategy) the OpenShift internal image registry `image-registry.openshift-image-registry.svc:5000` is used, unless the user explicitly specifies another registry.
In the internal registry, the project or namespace name is added as part of the image repository: `image-registry.openshift-image-registry.svc:5000/<project name>/<name>:<tag>`, so users must ensure that the target project or namespace name is aligned with the `quarkus.container-image.group`.
+
[source,properties]
----
quarkus.container-image.group=<project/namespace name>
----

* Generate Job resources
+
If you want to generate a Job resource, add the following property to your `application.properties` file:
+
[source,properties]
----
quarkus.openshift.deployment-kind=Job
----
+
[IMPORTANT]
====
If you are using the `Picocli` extension, the Job resource is generated by default.
====
+
You can use the `quarkus.openshift.arguments` property to provide the arguments that the Kubernetes job uses.
For example, specify `quarkus.openshift.arguments=A,B`.
+
Finally, the Kubernetes job launches every time that it is installed in OpenShift.
For more information about how to run Kubernetes jobs, see the link:https://kubernetes.io/docs/concepts/workloads/controllers/job/#running-an-example-job[Running an example job] topic in the Kubernetes documentation.
+
You can configure the rest of the Kubernetes job configuration by using the properties under `quarkus.openshift.job.xxx`.
For more information, see link:https://quarkus.io/guides/deploying-to-openshift#quarkus-openshift-openshift-config_quarkus.openshift.job.parallelism[quarkus.openshift.job.parallelism]).

* Generate CronJob resources
+
If you want to generate a CronJob resource, add the following property to your `application.properties` file:
+
[source,properties]
----
quarkus.openshift.deployment-kind=CronJob
# Cron expression to run the job every hour
quarkus.openshift.cron-job.schedule=0 * * * *
----
+
[IMPORTANT]
====
CronJob resources require the link:https://en.wikipedia.org/wiki/Cron[Cron] expression to specify when the `quarkus.openshift.cron-job.schedule` property starts the job, otherwise the build fails.
====
+
You can configure the rest of the Kubernetes CronJob configuration by using the properties under `quarkus.openshift.cron-job.xxx`.
For more information, see link:https://quarkus.io/guides/deploying-to-openshift#quarkus-openshift-openshift-config_quarkus.openshift.cron-job.parallelism[quarkus.openshift.cron-job.parallelism]).

==== Validation

If a conflict between two definitions occurs, for example, if you mistakenly both assign a value and specify that a variable is derived from a field, an error is thrown at build time.
By throwing the error at build time, you can fix the issue before you deploy your application to your cluster, where it might be more difficult to diagnose the source of the issue.

Similarly, two redundant definitions, for example, defining an injection from the same secret twice, does not cause an issue but still reports a warning to inform you that you might not have intended to duplicate that definition.

[#env-vars-backwards]
==== Backwards compatibility

Previous versions of the OpenShift extension supported a different syntax to add environment variables.
The older syntax is still supported, however it is deprecated.
It is recommended that you migrate to the new syntax.

.Comparison of syntax supported by earlier OpenShift extension versions and new syntax
|====
| Variable details                              |Old syntax                                                    | New syntax
| Plain variable                |`quarkus.openshift.env-vars.my-env-var.value=foobar`  | `quarkus.openshift.env.vars.my-env-var=foobar`
| From field                    |`quarkus.openshift.env-vars.my-env-var.field=foobar`  | `quarkus.openshift.env.fields.my-env-var=foobar`
| All from `ConfigMap`          |`quarkus.openshift.env-vars.xxx.configmap=foobar`     | `quarkus.openshift.env.configmaps=foobar`
| All from `Secret`             |`quarkus.openshift.env-vars.xxx.secret=foobar`        | `quarkus.openshift.env.secrets=foobar`
| From one `Secret` field       |`quarkus.openshift.env-vars.foo.secret=foobar`        | `quarkus.openshift.env.mapping.foo.from-secret=foobar`
|                               |`quarkus.openshift.env-vars.foo.value=field`          | `quarkus.openshift.env.mapping.foo.with-key=field`
| From one `ConfigMap` field    |`quarkus.openshift.env-vars.foo.configmap=foobar`     | `quarkus.openshift.env.mapping.foo.from-configmap=foobar`
|                               |`quarkus.openshift.env-vars.foo.value=field`          | `quarkus.openshift.env.mapping.foo.with-key=field`
|====

[NOTE]
====
If you redefine the same variable by using the new syntax while also keeping the old syntax, **ONLY** the new version is kept and a warning is issued to alert you of the problem.
For example, if you define both
`quarkus.openshift.env-vars.my-env-var.value=foobar` and `quarkus.openshift.env.vars.my-env-var=newValue`, the extension only generates the `MY_ENV_VAR=newValue` environment variable and issues a warning.
====

=== Mount volumes

You can use the OpenShift extension to configure both volumes and mounts for the application.

To mount any volume, specify the following configuration:

[source,properties]
----
quarkus.openshift.mounts.my-volume.path=/where/to/mount
----

This configuration adds a mount to my pod for `my-volume` volume to `/where/to/mount` path.

You can configure the volumes themselves as shown in the following sections:

==== Secret volumes

[source,properties]
----
quarkus.openshift.secret-volumes.my-volume.secret-name=my-secret
----

==== ConfigMap volumes

[source,properties]
----
quarkus.openshift.config-map-volumes.my-volume.config-map-name=my-config-map
----

==== Persistent volume claims

[source,properties]
----
quarkus.openshift.pvc-volumes.my-pvc.claim-name=my-pvc
----

:sectnums!:

== Configuration properties

include::{generated-dir}/config/quarkus-openshift-openshift-config.adoc[opts=optional, leveloffset=+1]

== References

* xref:container-image.adoc[Container images]
* xref:cli-tooling.adoc[Building Quarkus Apps with Quarkus CLI]
* xref:deploying-to-openshift.adoc[Deploy Quarkus applications to OpenShift Container Platform]
* xref:deploying-native-executable-openshift.adoc[Deploy your Quarkus applications compiled to native executables]
* xref:deploying-to-openshift-serveless.adoc[Deploy Quarkus applications as an OpenShift Serverless service]

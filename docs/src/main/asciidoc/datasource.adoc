////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
[id="datasources"]
= Configure data sources in {project-name}
include::_attributes.adoc[]
:diataxis-type: reference
:categories: data,getting-started,reactive
:topics: data,database,datasource,sql,jdbc,reactive
:extensions: io.quarkus:quarkus-agroal,io.quarkus:quarkus-reactive-mysql-client,io.quarkus:quarkus-reactive-oracle-client,io.quarkus:quarkus-reactive-pg-client,io.quarkus:quarkus-reactive-db2-client,io.quarkus:quarkus-reactive-pg-client,io.quarkus:quarkus-reactive-mssql-client,io.quarkus:quarkus-jdbc-db2,io.quarkus:quarkus-jdbc-derby,io.quarkus:quarkus-jdbc-h2,io.quarkus:quarkus-jdbc-mariadb,io.quarkus:quarkus-jdbc-mssql,io.quarkus:quarkus-jdbc-mysql,io.quarkus:quarkus-jdbc-oracle,io.quarkus:quarkus-jdbc-postgresql

Use a unified configuration model to define data sources for Java Database Connectivity (JDBC) and Reactive drivers.

////
Note for contributors and writers:
In text, use "data source". In code, "datasource" or "DataSource" is more common.
See, https://docs.oracle.com/javase/tutorial/jdbc/basics/connecting.html
////

Applications use datasources to access relational databases.
Quarkus provides a unified configuration model to define datasources for Java Database Connectivity (JDBC) and Reactive database drivers.

Quarkus uses link:https://agroal.github.io/[Agroal] and link:https://vertx.io/[Vert.x] to provide high-performance, scalable data source connection pooling for JDBC and reactive drivers.
The `quarkus-jdbc-\*` and `quarkus-reactive-*-client` extensions provide build time optimizations and integrate configured data sources with Quarkus features like security, health checks, and metrics.

For more information about consuming and using a reactive datasource, see the Quarkus xref:reactive-sql-clients.adoc[Reactive SQL clients] guide.

Additionally, refer to the Quarkus xref:hibernate-orm.adoc[Hibernate ORM] guide for information on consuming and using a JDBC datasource.


== Get started with configuring `datasources` in Quarkus

For users familiar with the fundamentals, this section provides an overview and code samples to set up data sources quickly.

For more advanced configuration with examples, see <<datasource-reference>>.

[[dev-services]]
=== Zero-config setup in development mode

Quarkus simplifies database configuration by offering the Dev Services feature, enabling zero-config database setup for testing or running in development (dev) mode.
In dev mode, the suggested approach is to use DevServices and let Quarkus handle the database for you, whereas for production mode, you provide explicit database configuration details pointing to a database managed outside of Quarkus.

To use Dev Services, add the appropriate driver extension, such as `jdbc-postgresql`, for your desired database type to the `pom.xml` file.
In dev mode, if you do not provide any explicit database connection details, Quarkus automatically handles the database setup and provides the wiring between the application and the database.

If you provide user credentials, the underlying database will be configured to use them.
This is useful if you want to connect to the database with an external tool.

To use this feature, ensure a Docker or Podman container runtime is installed, depending on the database type. Certain databases, such as H2, operate in in-memory mode and do not require a container runtime.

TIP: Prefix the actual connection details for prod mode with `%prod.` to ensure they are not applied in dev mode.
For more information, see the xref:config-reference.adoc#profiles[Profiles] section of the "Configuration reference" guide.

For more information about Dev Services, see xref:dev-services.adoc[Dev Services overview].

For more details and optional configurations, see xref:databases-dev-services.adoc[Dev Services for databases].


=== Configure a JDBC datasource

. Add the correct JDBC extension for the database of your choice.

* `quarkus-jdbc-db2`
* `quarkus-jdbc-derby`
* `quarkus-jdbc-h2`
* `quarkus-jdbc-mariadb`
* `quarkus-jdbc-mssql`
* `quarkus-jdbc-mysql`
* `quarkus-jdbc-oracle`
* `quarkus-jdbc-postgresql`

. Configure your JDBC datasource:
+
[source, properties]
----
quarkus.datasource.db-kind=postgresql <1>
quarkus.datasource.username=<your username>
quarkus.datasource.password=<your password>

quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
quarkus.datasource.jdbc.max-size=16
----
<1> This configuration value is only required if there is more than one database extension on the classpath.

If only one viable extension is available, Quarkus assumes this is the correct one.
When you add a driver to the test scope, Quarkus automatically includes the specified driver in testing.

==== JDBC connection pool size adjustment

To protect your database from overloading during load peaks, size the pool adequately to throttle the database load.
The optimal pool size depends on many factors, such as the number of parallel application users or the nature of the workload.

Be aware that setting the pool size too low might cause some requests to time out while waiting for a connection.

For more information about pool size adjustment properties, see the <<jdbc-configuration>> section.


=== Configure a reactive datasource

. Add the correct reactive extension for the database of your choice.

ifndef::no-quarkus-reactive-db2-client[]
* `quarkus-reactive-db2-client`
endif::no-quarkus-reactive-db2-client[]
* `quarkus-reactive-mssql-client`
* `quarkus-reactive-mysql-client`
* `quarkus-reactive-oracle-client`
* `quarkus-reactive-pg-client`

. Configure your reactive datasource:
+
[source, properties]
----
quarkus.datasource.db-kind=postgresql <1>
quarkus.datasource.username=<your username>
quarkus.datasource.password=<your password>

quarkus.datasource.reactive.url=postgresql:///your_database
quarkus.datasource.reactive.max-size=20
----
<1> This configuration value is only required if there is more than one Reactive driver extension on the classpath.

[[configure-datasources]]
== Configure datasources

The following section describes the configuration for single or multiple datasources.
For simplicity, we will reference a single datasource as the default (unnamed) datasource.

=== Configure a single datasource

A datasource can be either a JDBC datasource, reactive, or both.
This depends on the configuration and the selection of project extensions.

. Define a datasource with the following configuration property, where `db-kind` defines which database platform to connect to, for example, `h2`:
+
[source, properties]
----
quarkus.datasource.db-kind=h2
----
+
Quarkus deduces the JDBC driver class it needs to use from the specified value of the `db-kind` database platform attribute.
+
NOTE: This step is required only if your application depends on multiple database drivers.
If the application operates with a single driver, this driver is detected automatically.
+
Quarkus currently includes the following built-in database kinds:
+
* DB2: `db2`
* Derby: `derby`
* H2: `h2`
* MariaDB: `mariadb`
* Microsoft SQL Server: `mssql`
* MySQL: `mysql`
* Oracle: `oracle`
* PostgreSQL: `postgresql`, `pgsql` or `pg`
* To use a database kind that is not built-in, use `other` and define the JDBC driver explicitly
+
[NOTE]
====
You can use any JDBC driver in a Quarkus app in JVM mode as described in <<other-databases,Using other databases>>.
However, using a non-built-in database kind is unlikely to work when compiling your application to a native executable.

For native executable builds, it is recommended to either use the available JDBC Quarkus extensions or contribute a custom extension for your specific driver.
====

. Configure the following properties to define credentials:
+
[source, properties]
----
quarkus.datasource.username=<your username>
quarkus.datasource.password=<your password>
----
+
You can also retrieve the password from Vault by link:{vault-datasource-guide}[using a credential provider] for your datasource.

Until now, the configuration has been the same regardless of whether you are using a JDBC or a reactive driver.
When you have defined the database kind and the credentials, the rest depends on what type of driver you are using.
It is possible to use JDBC and a reactive driver simultaneously.

[[jdbc-datasource]]
==== JDBC datasource

JDBC is the most common database connection pattern, typically needed when used in combination with non-reactive Hibernate ORM.

. To use a JDBC datasource, start with adding the necessary dependencies:

.. For use with a built-in JDBC driver, choose and add the Quarkus extension for your relational database driver from the list below:
+
* Derby - `quarkus-jdbc-derby`
* H2 - `quarkus-jdbc-h2`
+
[NOTE]
====
H2 and Derby databases can be configured to run in "embedded mode"; however, the Derby extension does not support compiling the embedded database engine into native executables.

Read <<in-memory-databases,Testing with in-memory databases>> for suggestions regarding integration testing.
====
* DB2 - `quarkus-jdbc-db2`
* MariaDB - `quarkus-jdbc-mariadb`
* Microsoft SQL Server - `quarkus-jdbc-mssql`
* MySQL - `quarkus-jdbc-mysql`
* Oracle - `quarkus-jdbc-oracle`
* PostgreSQL - `quarkus-jdbc-postgresql`
* Other JDBC extensions, such as link:https://github.com/quarkiverse/quarkus-jdbc-sqlite[SQLite] and its link:https://quarkiverse.github.io/quarkiverse-docs/quarkus-jdbc-sqlite/dev/index.html[documentation], can be found in the https://github.com/quarkiverse[Quarkiverse].
+
For example, to add the PostgreSQL driver dependency:
+
[source,bash]
----
./mvnw quarkus:add-extension -Dextensions="jdbc-postgresql"
----
+
[NOTE]
====
Using a built-in JDBC driver extension automatically includes the Agroal extension, which is the JDBC connection pool implementation applicable for custom and built-in JDBC drivers.
However, for custom drivers, Agroal needs to be added explicitly.
====


.. For use with a custom JDBC driver, add the `quarkus-agroal` dependency to your project alongside the extension for your relational database driver:
+
[source,bash]
----
./mvnw quarkus:add-extension -Dextensions="agroal"
----
+
To use a JDBC driver for another database, <<other-databases,use a database with no built-in extension or with a different driver>>.


. Configure the JDBC connection by defining the JDBC URL property:
+
[source, properties]
----
quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
----
+
[NOTE]
====
Note the `jdbc` prefix in the property name.
All the configuration properties specific to JDBC have the `jdbc` prefix.
For reactive datasources, the prefix is `reactive`.
====

For more information about configuring JDBC, see <<jdbc-url,JDBC URL format reference>> and <<extensions-and-database-drivers-reference,Quarkus extensions and database drivers reference>>.


[[other-databases]]
===== Custom databases and drivers

If you need to connect to a database for which Quarkus does not provide an extension with the JDBC driver, you can use a custom driver instead.
For example, if you are using the OpenTracing JDBC driver in your project.

Without an extension, the driver will work correctly in any Quarkus app running in JVM mode.
However, the driver is unlikely to work when compiling your application to a native executable.
If you plan to make a native executable, use the existing JDBC Quarkus extensions, or contribute one for your driver.

[WARNING]
====
OpenTracing has been deprecated in favor of OpenTelemetry. For tracing information, please check the related section about <<datasource-tracing>>, bellow.
====

.A custom driver definition example with the legacy OpenTracing driver:

[source, properties]
----
quarkus.datasource.jdbc.driver=io.opentracing.contrib.jdbc.TracingDriver
----

.An example for defining access to a database with no built-in support in JVM mode:

[source, properties]
----
quarkus.datasource.db-kind=other
quarkus.datasource.jdbc.driver=oracle.jdbc.driver.OracleDriver
quarkus.datasource.jdbc.url=jdbc:oracle:thin:@192.168.1.12:1521/ORCL_SVC
quarkus.datasource.username=scott
quarkus.datasource.password=tiger
----

For all the details about the JDBC configuration options and configuring other aspects,
such as the connection pool size, refer to the <<jdbc-configuration,JDBC configuration reference>> section.

===== Consuming the datasource

With Hibernate ORM, the Hibernate layer automatically picks up the datasource and uses it.

For the in-code access to the datasource, obtain it as any other bean as follows:

[source,java]
----
@Inject
AgroalDataSource defaultDataSource;
----

In the above example, the type is `AgroalDataSource`, a `javax.sql.DataSource` subtype.
Because of this, you can also use `javax.sql.DataSource` as the injected type.

[[reactive-datasource]]
==== Reactive datasource

Quarkus offers several reactive clients for use with a reactive datasource.

. Add the corresponding extension to your application:
+
ifndef::no-quarkus-reactive-db2-client[]
* DB2: `quarkus-reactive-db2-client`
endif::no-quarkus-reactive-db2-client[]
* MariaDB/MySQL: `quarkus-reactive-mysql-client`
* Microsoft SQL Server: `quarkus-reactive-mssql-client`
* Oracle: `quarkus-reactive-oracle-client`
* PostgreSQL: `quarkus-reactive-pg-client`
+
The installed extension must be consistent with the `quarkus.datasource.db-kind` you define in your datasource configuration.

. After adding the driver, configure the connection URL and define a proper size for your connection pool.
+
[source,properties]
----
quarkus.datasource.reactive.url=postgresql:///your_database
quarkus.datasource.reactive.max-size=20
----

===== Reactive connection pool size adjustment

To protect your database from overloading during load peaks, size the pool adequately to throttle the database load.
The proper size always depends on many factors, such as the number of parallel application users or the nature of the workload.

Be aware that setting the pool size too low might cause some requests to time out while waiting for a connection.

For more information about pool size adjustment properties, see the <<reactive-configuration>> section.

[[jdbc-and-reactive-datasources-simultaneously]]
==== JDBC and reactive datasources simultaneously

When a JDBC extension - along with Agroal - and a reactive datasource extension handling the given database kind are included, they will both be created by default.

If you want to use them both,
make sure to set both <<jdbc-datasource,JDBC>> and <<reactive-datasource,reactive>> configuration,
for example:

[source,properties]
----
%prod.quarkus.datasource.reactive.url=postgresql:///your_database
%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
----

If you do not want to have both a JDBC datasource and a reactive datasource created, use the following configuration.
* To disable the JDBC datasource explicitly:
+
[source, properties]
----
quarkus.datasource.jdbc=false
----

* To disable the reactive datasource explicitly:
+
[source, properties]
----
quarkus.datasource.reactive=false
----
+
[TIP]
====
In most cases, the configuration above will be optional as either a JDBC driver or a reactive datasource extension will be present, not both.
====

=== Configure multiple datasources

[NOTE]
====
The Hibernate ORM extension supports defining xref:hibernate-orm.adoc#multiple-persistence-units[persistence units] by using configuration properties.
For each persistence unit, point to the datasource of your choice.
====

Defining multiple datasources works like defining a single datasource, with one important change - you have to specify a name (configuration property) for each datasource.

The following example provides three different datasources:

* the default one
* a datasource named `users`
* a datasource named `inventory`

Each with its configuration:

[source,properties]
----
quarkus.datasource.db-kind=h2
quarkus.datasource.username=username-default
quarkus.datasource.jdbc.url=jdbc:h2:mem:default
quarkus.datasource.jdbc.max-size=13

quarkus.datasource.users.db-kind=h2
quarkus.datasource.users.username=username1
quarkus.datasource.users.jdbc.url=jdbc:h2:mem:users
quarkus.datasource.users.jdbc.max-size=11

quarkus.datasource.inventory.db-kind=h2
quarkus.datasource.inventory.username=username2
quarkus.datasource.inventory.jdbc.url=jdbc:h2:mem:inventory
quarkus.datasource.inventory.jdbc.max-size=12
----

Notice there is an extra section in the configuration property.
The syntax is as follows: `quarkus.datasource.[optional name.][datasource property]`.

NOTE: Even when only one database extension is installed, named databases need to specify at least one build-time property so that Quarkus can detect them.
Generally, this is the `db-kind` property, but you can also specify Dev Services properties to create named datasources according to the xref:databases-dev-services.adoc[Dev Services for Databases] guide.

==== Named datasource injection

When using multiple datasources, each `DataSource` also has the `io.quarkus.agroal.DataSource` qualifier with the name of the datasource as the value.

By using the properties mentioned in the previous section to configure three different datasources, inject each one of them as follows:

[source,java,indent=0]
----
@Inject
AgroalDataSource defaultDataSource;

@Inject
@DataSource("users")
AgroalDataSource usersDataSource;

@Inject
@DataSource("inventory")
AgroalDataSource inventoryDataSource;
----

[[datasource-active]]
=== Activate/deactivate datasources

If a datasource is configured at build time,
by default it is active at runtime,
that is Quarkus will start the corresponding JDBC connection pool or reactive client on application startup.

To deactivate a datasource at runtime, set `quarkus.datasource[.optional name].active` to `false`.
Then Quarkus will not start the corresponding JDBC connection pool or reactive client on application startup.
Any attempt to use the corresponding datasource at runtime will fail with a clear error message.

This is in particular useful when you want an application to be able
to use one of a pre-determined set of datasources at runtime.

[WARNING]
====
If another Quarkus extension relies on an inactive datasource,
that extension might fail to start.

In such case, you will need to deactivate that other extension too.
For example see xref:hibernate-orm.adoc#persistence-unit-active[here for Hibernate ORM].
====

For example, with the following configuration:

[source,properties]
----
quarkus.datasource."pg".db-kind=postgres
quarkus.datasource."pg".active=false
quarkus.datasource."pg".jdbc.url=jdbc:postgresql:///your_database

quarkus.datasource."oracle".db-kind=oracle
quarkus.datasource."oracle".active=false
quarkus.datasource."oracle".jdbc.url=jdbc:oracle:///your_database
----

Setting `quarkus.datasource."pg".active=true` xref:config-reference.adoc#configuration-sources[at runtime]
will make only the PostgreSQL datasource available,
and setting `quarkus.datasource."oracle".active=true` at runtime
will make only the Oracle datasource available.

[TIP]
====
xref:config-reference.adoc#custom-profiles[Custom configuration profiles] can help simplify such a setup.
By appending the following profile-specific configuration to the one above,
you can select a persistence unit/datasource at runtime simply by
xref:config-reference.adoc#multiple-profiles[setting `quarkus.profile`]:
`quarkus.profile=prod,pg` or `quarkus.profile=prod,oracle`.

[source,properties]
----
%pg.quarkus.hibernate-orm."pg".active=true
%pg.quarkus.datasource."pg".active=true
# Add any pg-related runtime configuration here, prefixed with "%pg."

%oracle.quarkus.hibernate-orm."oracle".active=true
%oracle.quarkus.datasource."oracle".active=true
# Add any pg-related runtime configuration here, prefixed with "%pg."
----
====

[TIP]
====
It can also be useful to define a xref:cdi.adoc#ok-you-said-that-there-are-several-kinds-of-beans[CDI bean producer] redirecting to the currently active datasource,
like this:

[source,java,indent=0]
----
public class MyProducer {
    @Inject
    DataSourceSupport dataSourceSupport;

    @Inject
    @DataSource("pg")
    AgroalDataSource pgDataSourceBean;

    @Inject
    @DataSource("oracle")
    AgroalDataSource oracleDataSourceBean;

    @Produces
    @ApplicationScoped
    public AgroalDataSource dataSource() {
        if (dataSourceSupport.getInactiveNames().contains("pg")) {
            return oracleDataSourceBean;
        } else {
            return pgDataSourceBean;
        }
    }
}
----
====

[[datasource-multiple-single-transaction]]
=== Use multiple datasources in a single transaction

By default, XA support on datasources is disabled,
and thus a transaction may include at most one datasource.
Attempting to access multiple non-XA datasources in the same transaction
would result in an exception similar to this:

[source]
----
...
Caused by: java.sql.SQLException: Exception in association of connection to existing transaction
        at io.agroal.narayana.NarayanaTransactionIntegration.associate(NarayanaTransactionIntegration.java:130)
        ...
Caused by: java.sql.SQLException: Failed to enlist. Check if a connection from another datasource is already enlisted to the same transaction
        at io.agroal.narayana.NarayanaTransactionIntegration.associate(NarayanaTransactionIntegration.java:121)
        ...
----

To allow using multiple JDBC datasources in the same transaction:

. Make sure your JDBC driver supports XA.
All <<extensions-and-database-drivers-reference,supported JDBC drivers do>>,
but <<other-databases,other JDBC drivers>> might not.
. Make sure your database server is configured to enable XA.
. Enable XA support explicitly for each relevant datasource by setting
<<quarkus-agroal_quarkus-datasource-jdbc-transactions,`quarkus.datasource[.optional name].jdbc.transactions`>> to `xa`.

Using XA, a rollback in one datasource will trigger a rollback in every other datasource enrolled in the transaction.

[NOTE]
====
XA transactions on reactive datasources are not supported at the moment.
====

[NOTE]
====
If your transaction involves other, non-datasource resources,
keep in mind *those* resources might not support XA transactions,
or might require additional configuration.
====

If XA cannot be enabled for one of your datasources:

* Be aware that enabling XA for all datasources _except one_ (and only one) is still supported
through https://www.narayana.io/docs/project/index.html#d5e857[Last Resource Commit Optimization (LRCO)].
* If you do not need a rollback for one datasource to trigger a rollback for other datasources,
consider splitting your code into multiple transactions.
To that end, use xref:transaction.adoc#programmatic-approach[`QuarkusTransaction.requiringNew()`]/xref:transaction.adoc#declarative-approach[`@Transactional(REQUIRES_NEW)`] (preferably)
or xref:transaction.adoc#legacy-api-approach[`UserTransaction`] (for more complex use cases).

[CAUTION]
====
As a last resort, and for compatibility with Quarkus 3.8 and earlier,
you may allow unsafe transaction handling across multiple non-XA datasources
by setting `quarkus.transaction-manager.unsafe-multiple-last-resources` to `allow`.

With this property set to `allow`, a transaction rollback
could possibly be applied to only some of the non-XA datasources,
with other non-XA datasources having already committed their changes,
leaving your overall system in an inconsistent state.

Alternatively, you can allow the same unsafe behavior,
but with warnings when it is taken advantage of:

* setting the property to `warn-each`
would result in logging a warning on *each* offending transaction.
* setting the property to `warn-first`
would result in logging a warning on the *first* offending transaction.

We do not recommend using this configuration property,
and we plan to remove it in the future,
so you should plan fixing your application accordingly.
If you think your use case of this feature is valid and this option should be kept around,
open an issue in the https://github.com/quarkusio/quarkus/issues/new?assignees=&labels=kind%2Fenhancement&projects=&template=feature_request.yml[Quarkus tracker]
explaining why.
====

== Datasource integrations

=== Datasource health check

If you use the link:https://quarkus.io/extensions/io.quarkus/quarkus-smallrye-health[`quarkus-smallrye-health`] extension, the `quarkus-agroal` and reactive client extensions automatically add a readiness health check to validate the datasource.

When you access your application’s health readiness endpoint, `/q/health/ready` by default, you receive information about the datasource validation status.
If you have multiple datasources, all datasources are checked, and if a single datasource validation failure occurs, the status changes to `DOWN`.

This behavior can be disabled by using the `quarkus.datasource.health.enabled` property.

To exclude only a particular datasource from the health check, use:

[source,properties]
----
quarkus.datasource."datasource-name".health-exclude=true
----

=== Datasource metrics

If you are using the xref:telemetry-micrometer.adoc[`quarkus-micrometer`] or xref:smallrye-metrics.adoc[`quarkus-smallrye-metrics`] extension, `quarkus-agroal` can contribute some datasource-related metrics to the metric registry.
This can be activated by setting the `quarkus.datasource.metrics.enabled` property to `true`.

For the exposed metrics to contain any actual values, a metric collection must be enabled internally by the Agroal mechanisms.
By default, this metric collection mechanism is enabled for all datasources when a metrics extension is present, and metrics for the Agroal extension are enabled.

To disable metrics for a particular data source,
set `quarkus.datasource.jdbc.enable-metrics` to `false`, or apply `quarkus.datasource.<datasource name>.jdbc.enable-metrics` for a named datasource.
This disables collecting the metrics and exposing them in the `/q/metrics` endpoint if the mechanism to collect them is disabled.

Conversely, setting `quarkus.datasource.jdbc.enable-metrics` to `true`, or `quarkus.datasource.<datasource name>.jdbc.enable-metrics` for a named datasource explicitly enables metrics collection even if a metrics extension is not in use.
This can be useful if you need to access the collected metrics programmatically.
They are available after calling `dataSource.getMetrics()` on an injected `AgroalDataSource` instance.

If the metrics collection for this datasource is disabled, all values result in zero.

[[datasource-tracing]]
=== Datasource tracing

To use tracing with a datasource, you need to add the xref:opentelemetry-tracing.adoc[`quarkus-opentelemetry`] extension to your project.

You don't need to declare a different driver because you need tracing. If you use a JDBC driver, you need to follow the instructions in the OpenTelemetry extension xref:opentelemetry-tracing.adoc#jdbc[here].

Even with all the tracing infrastructure in place the datasource tracing is not enabled by default, and you need to enable it by setting this property:
[source, properties]
----
# enable tracing
quarkus.datasource.jdbc.telemetry=true
----

=== Narayana transaction manager integration

Integration is automatic if the Narayana JTA extension is also available.

You can override this by setting the `transactions` configuration property:

* `quarkus.datasource.jdbc.transactions` for default unnamed datasource
* `quarkus.datasource._<datasource-name>_.jdbc.transactions` for named datasource

For more information, see the <<configuration-reference,Configuration reference>> section below.

To facilitate the storage of transaction logs in a database by using JDBC, see xref:transaction.adoc#jdbcstore[Configuring transaction logs to be stored in a datasource] section of the xref:transaction.adoc[Using transactions in Quarkus] guide.

==== Named datasources

When using Dev Services, the default datasource will always be created, but to specify a named datasource, you need to have at least one build time property so Quarkus can detect how to create the datasource.

You will usually specify the `db-kind` property or explicitly enable Dev Services by setting `quarkus.datasource."name".devservices.enabled=true`.

[[in-memory-databases]]
=== Testing with in-memory databases

Some databases like H2 and Derby are commonly used in the _embedded mode_ as a facility to run integration tests quickly.

The recommended approach is to use the real database you intend to use in production, especially when xref:databases-dev-services.adoc[Dev Services provide a zero-config database for testing], and running tests against a container is relatively quick and produces expected results on an actual environment.
However, it is also possible to use JVM-powered databases for scenarios when the ability to run simple integration tests is required.


==== Support and limitations

Embedded databases (H2 and Derby) work in JVM mode.
For native mode, the following limitations apply:

* Derby cannot be embedded into the application in native mode.
However, the Quarkus Derby extension allows native compilation of the Derby JDBC *client*, supporting *remote* connections.

* Embedding H2 within your native image is not recommended.
Consider using an alternative approach, for example, using a remote connection to a separate database instead.

ifndef::no-deprecated-test-resource[]
==== Run an integration test

. Add a dependency on the artifacts providing the additional tools that are under the following Maven coordinates:
+
* `io.quarkus:quarkus-test-h2` for H2
* `io.quarkus:quarkus-test-derby` for Derby
+
This will allow you to test your application even when it is compiled into a native executable while the database will run as a JVM process.

. Add the following specific annotation on any class in your integration tests for running integration tests in both JVM or native executables:
+
* `@WithTestResource(H2DatabaseTestResource.class)`
* `@WithTestResource(DerbyDatabaseTestResource.class)`
+
This ensures that the test suite starts and terminates the managed database in a separate process as required for test execution.
+
.H2 example
[source,java]
----
package my.app.integrationtests.db;

import io.quarkus.test.common.WithTestResource;
import io.quarkus.test.h2.H2DatabaseTestResource;

@WithTestResource(H2DatabaseTestResource.class)
public class TestResources {
}
----

. Configure the connection to the managed database:
+
[source,properties]
----
quarkus.datasource.db-kind=h2
quarkus.datasource.jdbc.url=jdbc:h2:tcp://localhost/mem:test
----
endif::no-deprecated-test-resource[]

[[datasource-reference]]
== References

[[configuration-reference]]
=== Common datasource configuration reference

include::{generated-dir}/config/quarkus-datasource.adoc[opts=optional, leveloffset=+1]

[[jdbc-configuration]]
=== JDBC configuration reference

include::{generated-dir}/config/quarkus-agroal.adoc[opts=optional, leveloffset=+1]

[[jdbc-url]]
=== JDBC URL reference

Each of the supported databases contains different JDBC URL configuration options.
The following section gives an overview of each database URL and a link to the official documentation.

==== DB2

`jdbc:db2://<serverName>[:<portNumber>]/<databaseName>[:<key1>=<value>;[<key2>=<value2>;]]`

Example:: `jdbc:db2://localhost:50000/MYDB:user=dbadm;password=dbadm;`

For more information on URL syntax and additional supported options, see the link:https://www.ibm.com/support/knowledgecenter/SSEPGG_11.5.0/com.ibm.db2.luw.apdv.java.doc/src/tpc/imjcc_r0052342.html[official documentation].

==== Derby

`jdbc:derby:[//serverName[:portNumber]/][memory:]databaseName[;property=value[;property=value]]`

Example:: `jdbc:derby://localhost:1527/myDB`, `jdbc:derby:memory:myDB;create=true`

Derby is an embedded database that can run as a server, based on a file, or can run completely in memory.
All of these options are available as listed above.

For more information, see the link:https://db.apache.org/derby/docs/10.8/devguide/cdevdvlp17453.html#cdevdvlp17453[official documentation].

==== H2

`jdbc:h2:{ {.|mem:}[name] | [file:]fileName | {tcp|ssl}:[//]server[:port][,server2[:port]]/name }[;key=value...]`

Example:: `jdbc:h2:tcp://localhost/~/test`, `jdbc:h2:mem:myDB`

H2 is a database that can run in embedded or server mode.
It can use a file storage or run entirely in memory.
All of these options are available as listed above.

For more information, see the link:https://h2database.com/html/features.html#database_url[official documentation].

==== MariaDB

`jdbc:mariadb:[replication:|failover:|sequential:|aurora:]//<hostDescription>[,<hostDescription>...]/[database][?<key1>=<value1>[&<key2>=<value2>]]`
hostDescription:: `<host>[:<portnumber>] or address=(host=<host>)[(port=<portnumber>)][(type=(master|slave))]`

Example:: `jdbc:mariadb://localhost:3306/test`

For more information, see the link:https://mariadb.com/kb/en/library/about-mariadb-connector-j/[official documentation].

==== Microsoft SQL server

`jdbc:sqlserver://[serverName[\instanceName][:portNumber]][;property=value[;property=value]]`

Example:: `jdbc:sqlserver://localhost:1433;databaseName=AdventureWorks`

The Microsoft SQL Server JDBC driver works essentially the same as the others.

For more information, see the link:https://docs.microsoft.com/en-us/sql/connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver?view=sql-server-2017[official documentation].

==== MySQL

`jdbc:mysql:[replication:|failover:|sequential:|aurora:]//<hostDescription>[,<hostDescription>...]/[database][?<key1>=<value1>[&<key2>=<value2>]]`
hostDescription:: `<host>[:<portnumber>] or address=(host=<host>)[(port=<portnumber>)][(type=(master|slave))]`

Example:: `jdbc:mysql://localhost:3306/test`

For more information, see the link:https://dev.mysql.com/doc/connector-j/en/[official documentation].

===== MySQL limitations

When compiling a Quarkus application to a native image, the MySQL support for JMX and Oracle Cloud Infrastructure (OCI) integrations are disabled as they are incompatible with GraalVM native images.

* The lack of JMX support is a natural consequence of running in native mode and is unlikely to be resolved.
* The integration with OCI is not supported.

==== Oracle

`jdbc:oracle:driver_type:@database_specifier`

Example:: `jdbc:oracle:thin:@localhost:1521/ORCL_SVC`

For more information, see the link:https://docs.oracle.com/en/database/oracle/oracle-database/21/jjdbc/data-sources-and-URLs.html#GUID-AEA8E228-1B21-4111-AF4C-B1F33744CA08[official documentation].

==== PostgreSQL

`jdbc:postgresql:[//][host][:port][/database][?key=value...]`

Example:: `jdbc:postgresql://localhost/test`

The defaults for the different parts are as follows:

`host`:: localhost
`port`:: 5432
`database`:: same name as the username

For more information about additional parameters, see the link:https://jdbc.postgresql.org/documentation/head/connect.html[official documentation].


[[extensions-and-database-drivers-reference]]
=== Quarkus extensions and database drivers reference

The following tables list the built-in `db-kind` values, the corresponding Quarkus extensions, and the JDBC drivers used by those extensions.

When using one of the built-in datasource kinds, the JDBC and Reactive drivers are resolved automatically to match the values from these tables.

.Database platform kind to JDBC driver mapping
[options="header",cols="^10%,^25%,65%"]
|===
|Database kind |Quarkus extension |Drivers

|`db2`
|`quarkus-jdbc-db2`
a|* JDBC: `com.ibm.db2.jcc.DB2Driver`

* XA: `com.ibm.db2.jcc.DB2XADataSource`

|`derby`
|`quarkus-jdbc-derby`
a|* JDBC: `org.apache.derby.jdbc.ClientDriver`

* XA: `org.apache.derby.jdbc.ClientXADataSource`

|`h2`
|`quarkus-jdbc-h2`
a|* JDBC: `org.h2.Driver`

* XA: `org.h2.jdbcx.JdbcDataSource`

|`mariadb`
|`quarkus-jdbc-mariadb`
a|* JDBC: `org.mariadb.jdbc.Driver`

* XA: `org.mariadb.jdbc.MySQLDataSource`

|`mssql`
|`quarkus-jdbc-mssql`
a|* JDBC: `com.microsoft.sqlserver.jdbc.SQLServerDriver`

* XA: `com.microsoft.sqlserver.jdbc.SQLServerXADataSource`

|`mysql`
|`quarkus-jdbc-mysql`
a|* JDBC: `com.mysql.cj.jdbc.Driver`

* XA: `com.mysql.cj.jdbc.MysqlXADataSource`

|`oracle`
|`quarkus-jdbc-oracle`
a|* JDBC: `oracle.jdbc.driver.OracleDriver`

* XA: `oracle.jdbc.xa.client.OracleXADataSource`

|`postgresql`
|`quarkus-jdbc-postgresql`
a|* JDBC: `org.postgresql.Driver`

* XA: `org.postgresql.xa.PGXADataSource`
|===


.Database kind to Reactive driver mapping
[options="header",cols="^10%,^25%,65%"]
|===
|Database kind |Quarkus extension |Driver

|`oracle`
|`reactive-oracle-client`
|`io.vertx.oracleclient.spi.OracleDriver`

|`mysql`
|`reactive-mysql-client`
|`io.vertx.mysqlclient.spi.MySQLDriver`

|`mssql`
|`reactive-mssql-client`
|`io.vertx.mssqlclient.spi.MSSQLDriver`

|`postgresql`
|`reactive-pg-client`
|`io.vertx.pgclient.spi.PgDriver`

ifndef::no-quarkus-reactive-db2-client[]
|`db2`
|`reactive-db2-client`
|`io.vertx.db2client.spi.DB2Driver`
endif::no-quarkus-reactive-db2-client[]
|===

[TIP]
====
This automatic resolution is applicable in most cases so that driver configuration is not needed.
====


[[reactive-configuration]]
=== Reactive datasource configuration reference

include::{generated-dir}/config/quarkus-reactive-datasource.adoc[opts=optional, leveloffset=+1]

ifndef::no-quarkus-reactive-db2-client[]
==== Reactive DB2 configuration

include::{generated-dir}/config/quarkus-reactive-db2-client.adoc[opts=optional, leveloffset=+1]
endif::no-quarkus-reactive-db2-client[]

==== Reactive MariaDB/MySQL specific configuration

include::{generated-dir}/config/quarkus-reactive-mysql-client.adoc[opts=optional, leveloffset=+1]

==== Reactive Microsoft SQL server-specific configuration

include::{generated-dir}/config/quarkus-reactive-mssql-client.adoc[opts=optional, leveloffset=+1]

==== Reactive Oracle-specific configuration

include::{generated-dir}/config/quarkus-reactive-oracle-client.adoc[opts=optional, leveloffset=+1]

==== Reactive PostgreSQL-specific configuration

include::{generated-dir}/config/quarkus-reactive-pg-client.adoc[opts=optional, leveloffset=+1]


[[reactive-url]]
=== Reactive datasource URL reference

==== DB2

`db2://[user[:[password]]@]host[:port][/database][?<key1>=<value1>[&<key2>=<value2>]]`

Example:: `db2://dbuser:secretpassword@database.server.com:50000/mydb`

Currently, the client supports the following parameter keys:

* `host`
* `port`
* `user`
* `password`
* `database`

NOTE: Configuring parameters in the connection URL overrides the default properties.

==== Microsoft SQL server

`sqlserver://[user[:[password]]@]host[:port][/database][?<key1>=<value1>[&<key2>=<value2>]]`

Example:: `sqlserver://dbuser:secretpassword@database.server.com:1433/mydb`

Currently, the client supports the following parameter keys:

* `host`
* `port`
* `user`
* `password`
* `database`

NOTE: Configuring parameters in the connection URL overrides the default properties.

==== MySQL / MariaDB

`mysql://[user[:[password]]@]host[:port][/database][?<key1>=<value1>[&<key2>=<value2>]]`

Example:: `mysql://dbuser:secretpassword@database.server.com:3211/mydb`

Currently, the client supports the following parameter keys (case-insensitive):

* `host`
* `port`
* `user`
* `password`
* `schema`
* `socket`
* `useAffectedRows`

NOTE: Configuring parameters in the connection URL overrides the default properties.

==== Oracle

===== EZConnect format

`oracle:thin:@[[protocol:]//]host[:port][/service_name][:server_mode][/instance_name][?connection properties]`

Example:: `oracle:thin:@mydbhost1:5521/mydbservice?connect_timeout=10sec`

===== TNS alias format

`oracle:thin:@<alias_name>[?connection properties]`

Example:: `oracle:thin:@prod_db?TNS_ADMIN=/work/tns/`

==== PostgreSQL

`postgresql://[user[:[password]]@]host[:port][/database][?<key1>=<value1>[&<key2>=<value2>]]`

Example:: `postgresql://dbuser:secretpassword@database.server.com:5432/mydb`

Currently, the client supports:

* Following parameter keys:
** `host`
** `port`
** `user`
** `password`
** `dbname`
** `sslmode`

* Additional properties, such as:
** `application_name`
** `fallback_application_name`
** `search_path`
** `options`

NOTE: Configuring parameters in the connection URL overrides the default properties.

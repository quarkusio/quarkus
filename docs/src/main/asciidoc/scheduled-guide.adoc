////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Quarkus - Scheduling Periodic Tasks

include::./attributes.adoc[]

Modern applications often need to run specific tasks periodically.
In this guide, you learn how to schedule periodic tasks.

== Prerequisites

To complete this guide, you need:

* less than 10 minutes
* an IDE
* JDK 1.8+ installed with `JAVA_HOME` configured appropriately
* Apache Maven 3.5.3+



== Architecture

In this guide, we create a straightforward application accessible using HTTP to get the current value of a counter.
This counter is periodically (every 10 seconds) incremented.

image:scheduling-task-architecture.png[alt=Architecture]

== Solution

We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `scheduling-periodic-tasks` directory.

== Creating the Maven project

First, we need a new project. Create a new project with the following command:

[source,shell,subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=scheduling-periodic-tasks \
    -DclassName="org.acme.scheduling.CountResource" \
    -Dpath="/count" \
    -Dextensions="scheduler"
----

It generates:

* the Maven structure
* a landing page accessible on `http://localhost:8080`
* example `Dockerfile` files for both `native` and `jvm` modes
* the application configuration file
* an `org.acme.scheduling.CountResource` resource
* an associated test

The Maven project also imports the Quarkus scheduler extension.

== Creating a scheduled job

In the `org.acme.scheduling` package, create the `CounterBean` class, with the following content:

[source,java]
----
package org.acme.scheduling;

import java.util.concurrent.atomic.AtomicInteger;
import javax.enterprise.context.ApplicationScoped;
import io.quarkus.scheduler.Scheduled;

@ApplicationScoped              // <1>
public class CounterBean {

    private AtomicInteger counter = new AtomicInteger();

    public int get() {  // <2>
        return counter.get();
    }

    @Scheduled(every="10s")     // <3>
    void increment() {
        counter.incrementAndGet(); // <4>
    }

}
----
1. Declare the bean in the _application_ scope
2. The `get()` method allows retrieving the current value.
3. Use the `@Scheduled` annotation to instruct Quarkus to run this method every 10 seconds provided a worker thread is available
(Quarkus is using 10 worker threads for the scheduler). If it is not available the method invocation should be re-scheduled by default i.e
it should be invoked as soon as possible. The invocation of the scheduled method does not depend on the status or result of the previous invocation.
4. The code is pretty straightforward. Every 10 seconds, the counter is incremented.

NOTE: Cron-like expressions are also supported. The syntax is currently based on Quartz Cron Trigger. For example a method annotated with `@Scheduled(cron="0 15 10 * * ?")` is executed at 10:15am every day.

== Updating the resource and the test


Edit the `CountResource` class, and update the content to:

[source,java]
----
package org.acme.scheduling;

import javax.inject.Inject;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;

@Path("/count")
public class CountResource {

    @Inject
    CounterBean counter;            // <1>


    @GET
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        return "count: " + counter.get();  // <2>
    }
}
----
1. Inject the `CounterBean`
2. Send back the current counter value

We also need to update the tests. Edit the `CountResourceTest` class to match:

[source, java]
----
package org.acme.scheduling;

import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.containsString;

@QuarkusTest
public class CountResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/count")
          .then()
             .statusCode(200)
             .body(containsString("count")); // <1>
    }

}
----
1. Ensure that the response contains `count`

== Scheduler configurations

`quarkus.scheduler.instance-name`:: The instance name of the scheduler.
+
Type: `java.lang.String` +
Defaults to: `DefaultQuartzScheduler` +


`quarkus.scheduler.state-store.misfire-threshold`:: The number of duration by which a trigger must have missed its next-fire-time, in order for it to be considered "misfired" and thus have its misfire instruction applied.
+
Type: `java.time.Duration` +
Defaults to: `1m` +


`quarkus.scheduler.state-store.cluster-checking-interval`:: The frequency at which this instance "checks-in" with the other instances of the cluster .This affects the rate of detecting failed instances.
+
Type: `java.time.Duration` +
Defaults to: `20s` +


`quarkus.scheduler.state-store.cluster-enabled`:: Enable cluster mode or not. This takes effect if the <<state-store-type, state store>> is `jdbc`.
+
Type: `java.lang.Boolean` +


`quarkus.scheduler.state-store.driver-delegate-class`:: The JDBC driver delegate class. This is not required if the <<state-store-type, state store>> is `in-memory`.
Otherwise it must be set to a delegate class corresponding to the SQL driver in use.
Possible values can be obtained from https://github.com/quartz-scheduler/quartz/tree/master/quartz-core/src/main/java/org/quartz/impl/jdbcjobstore[quartz-scheduler JDBC stores delegate]
+
Type: `java.lang.String` +
Defaults to: `org.quartz.impl.jdbcjobstore.StdJDBCDelegate` +

[[state-store-type]]
`quarkus.scheduler.state-store`:: The type of state store to use. Possible values are: `in-memory`, and `jdbc`.
 -  If set to `in-memory`, the scheduler will use the `org.quartz.simpl.RAMJobStore` job store class
 -  If set to `jdbc`, the scheduler will use the `org.quartz.impl.jdbcjobstore.JobStoreTX` job store class.
 When using this option make sure that you have the link:datasource-guide.html[agroal datasource configured] and that <<creating-scheduling-job, scheduling tables>> exists.
 This store type is not supported in Native Image because of https://github.com/oracle/graal/issues/460[unsupported Object serialization].
+
Type: `io.quarkus.scheduler.runtime.SchedulerBuildTimeConfig.StoreType` +
Defaults to: `in-memory` +


`quarkus.scheduler.instance-id`:: The instance id of the scheduler. This is highly required when running clustered schedulers as each node in the cluster MUST have a unique instanceId.
Defaults to `AUTO` to automatically generate unique ids for each node in the cluster
+
Type: `java.lang.String` +
Defaults to: `AUTO` +


`quarkus.scheduler.thread-count`:: The size of scheduler thread pool. This will initialise the number of worker threads in the pool
+
Type: `int` +
Defaults to: `25` +


`quarkus.scheduler.thread-priority`:: Thread priority of worker threads in the pool.
+
Type: `int` +
Defaults to: `5` +

include::duration-format-note.adoc[]

[TIP]
[[creating-scheduling-job]]
.About creating database tables when using `jdbc` state store
=====
The Quarkus scheduler does not create the necessary scheduling tables in database automatically. If these tables are missing, the schuduler will throw an excpetion during application startup.
Thus you'll need to create them. To do so, choose a file corresponding to your SQL driver from https://github.com/quartz-scheduler/quartz/tree/master/quartz-core/src/main/resources/org/quartz/impl/jdbcjobstore[quartz sql script files].
Once you are done, you can use the link:flyway-guide.html[flyway extension] to execute table creation using the choosen SQL file.
=====

== Package and run the application

Run the application with: `./mvnw compile quarkus:dev`.
In another terminal, run `curl localhost:8080/count` to check the counter value.
After a few seconds, re-run `curl localhost:8080/count` to verify the counter has been incremented.

As usual, the application can be packaged using `./mvnw clean package` and executed using the `-runner.jar` file.
You can also generate the native executable with `./mvnw clean package -Pnative`.

////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/main/docs/src/main/asciidoc
////
= Using Hibernate Reactive
include::_attributes.adoc[]
:config-file: application.properties
:reactive-doc-url-prefix: https://hibernate.org/reactive/documentation/1.1/reference/html_single/#getting-started
:extension-status: preview
:topics: data,hibernate-reactive,sql
:extensions: io.quarkus:quarkus-hibernate-reactive-panache,io.quarkus:quarkus-hibernate-reactive

link:https://hibernate.org/reactive/[Hibernate Reactive] is a reactive API for Hibernate ORM, supporting non-blocking database drivers
and a reactive style of interaction with the database.

[NOTE]
====
Hibernate Reactive is not a replacement for xref:hibernate-orm.adoc[Hibernate ORM] or the future of Hibernate ORM.
It is a different stack tailored for reactive use cases where you need high-concurrency.

Also, using Quarkus REST (formerly RESTEasy Reactive), our default REST layer, does not require the use of Hibernate Reactive.
It is perfectly valid to use Quarkus REST with Hibernate ORM,
and if you do not need high-concurrency, or are not accustomed to the reactive paradigm, it is recommended to use Hibernate ORM.
====

[NOTE]
====
Hibernate Reactive works with the same annotations and most of the configuration described in the
xref:hibernate-orm.adoc[Hibernate ORM guide]. This guide will only focus on what's specific
for Hibernate Reactive.
====

include::{includes}/extension-status.adoc[]

== Solution

We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `hibernate-reactive-quickstart` link:{quickstarts-tree-url}/hibernate-reactive-quickstart[directory].

[[hr-getting-started]]
== Setting up and configuring Hibernate Reactive

When using Hibernate Reactive in Quarkus, you need to:

* add your configuration settings in `{config-file}`
* annotate your entities with `@Entity` and any other mapping annotations as usual

Other configuration needs have been automated: Quarkus will make some opinionated choices and educated guesses.

Add the following dependencies to your project:

* the Hibernate Reactive extension: `io.quarkus:quarkus-hibernate-reactive`
* the xref:reactive-sql-clients.adoc[Reactive SQL client extension] for the database of your choice; the following options are available:
  - `quarkus-reactive-pg-client`: link:https://vertx.io/docs/vertx-pg-client/java[the client for PostgreSQL or CockroachDB]
  - `quarkus-reactive-mysql-client`: link:https://vertx.io/docs/vertx-mysql-client/java[the client MySQL or MariaDB]
  - `quarkus-reactive-mssql-client`: link:https://vertx.io/docs/vertx-mssql-client/java[the client for Microsoft SQL Server]
  - `quarkus-reactive-db2-client`: link:https://vertx.io/docs/vertx-db2-client/java[the client for IBM Db2]
  - `quarkus-reactive-oracle-client`: link:https://vertx.io/docs/vertx-oracle-client/java[the client for Oracle]

For instance:

[source,xml,role="primary asciidoc-tabs-target-sync-cli asciidoc-tabs-target-sync-maven"]
.pom.xml
----
<!-- Hibernate Reactive dependency -->
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-hibernate-reactive</artifactId>
</dependency>

<!-- Reactive SQL client for PostgreSQL -->
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-reactive-pg-client</artifactId>
</dependency>
----

[source,gradle,role="secondary asciidoc-tabs-target-sync-gradle"]
.build.gradle
----
// Hibernate Reactive dependency
implementation("io.quarkus:quarkus-hibernate-reactive")

Reactive SQL client for PostgreSQL
implementation("io.quarkus:quarkus-reactive-pg-client")
----

Annotate your persistent objects with `@Entity`,
then add the relevant configuration properties in `{config-file}`:

[source,properties]
.Example `{config-file}`
----
# datasource configuration
quarkus.datasource.db-kind = postgresql
quarkus.datasource.username = quarkus_test
quarkus.datasource.password = quarkus_test

quarkus.datasource.reactive.url = vertx-reactive:postgresql://localhost/quarkus_test <1>

# drop and create the database at startup (use `update` to only update the schema)
quarkus.hibernate-orm.schema-management.strategy=drop-and-create
----

<1> The only different property from a Hibernate ORM configuration

Note that these configuration properties are not the same ones as in your typical Hibernate Reactive configuration file.
They will often map to Hibernate Reactive configuration properties but could have different names and don't necessarily map 1:1 to each other.

Blocking (non-reactive) and reactive configuration xref:orm-and-reactive-extension-simultaneously[can be mixed together in the same project].

WARNING: Configuring Hibernate Reactive using the standard `persistence.xml` configuration file is not supported.

See section <<configuration-reference>> for the list of properties you can set in `{config-file}`.

A `Mutiny.SessionFactory` will be created based on the Quarkus `datasource` configuration as long as the Hibernate Reactive extension is listed among your project dependencies.

The dialect will be selected based on the Reactive SQL client - unless you set one explicitly.

NOTE: For more information on dialect selection and database versions,
see xref:hibernate-orm.adoc#hibernate-dialect[the corresponding section of the Hibernate ORM guide].

You can then happily inject your `Mutiny.SessionFactory`:

[source,java]
.Example application bean using Hibernate Reactive
----
@ApplicationScoped
public class SantaClausService {
    @Inject
    Mutiny.SessionFactory sf; <1>

    public Uni<Void> createGift(String giftDescription) {
	Gift gift = new Gift();
        gift.setName(giftDescription);
	return sf.withTransaction(session -> session.persist(gift)) <2>
    }
}
----

<1> Inject your session factory and have fun
<2> `.withTransaction()` will automatically flush at commit

WARNING: Make sure to wrap methods modifying your database (e.g. `session.persist(entity)`) within a transaction.

[source,java]
.Example of an Entity
----
@Entity
public class Gift {
    private Long id;
    private String name;

    @Id
    @SequenceGenerator(name = "giftSeq", sequenceName = "gift_id_seq", allocationSize = 1, initialValue = 1)
    @GeneratedValue(generator = "giftSeq")
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
----

To load SQL statements when Hibernate Reactive starts, add an `import.sql` file in your `src/main/resources/` directory.
This script can contain any SQL DML statements.
Make sure to terminate each statement with a semicolon.

This is useful to have a data set ready for your tests or demos.

=== Using `@Transactional` with Hibernate Reactive

You can use the standard `jakarta.transaction.Transactional` annotation with Hibernate Reactive as well.
This provides a more familiar programming model for developers coming from Hibernate ORM.
Support for `@Transactional` in Hibernate Reactive is provided by the `quarkus-reactive-transactions` module, implcitly imported by Hibernate Reactive.

While defining transaction handling using the annotation, you should inject `Mutiny.Session` or `Mutiny.StatelessSession` directly and use them in methods annotated with `@Transactional`.

Here's an example showing how to use `@Transactional` in a REST resource:

[source,java]
.Example REST resource using @Transactional
----
@Path("/fruits")
public class FruitResource {

    @Inject
    Mutiny.Session session; <1>

    @GET
    @Path("/{id}")
    public Uni<Fruit> getFruit(Long id) {
        return session.find(Fruit.class, id);
    }

    @POST
    @Transactional <2>
    public Uni<Fruit> createFruit(Fruit fruit) {
        return session.persist(fruit)
                .chain(() -> session.find(Fruit.class, fruit.getId()));
    }

    @PUT
    @Path("/{id}")
    @Transactional <3>
    public Uni<Fruit> updateFruit(Long id, @QueryParam("name") String newName) {
        return session.find(Fruit.class, id)
                .map(fruit -> {
                    fruit.setName(newName);
                    return fruit;
                });
    }

}
----

<1> Inject the reactive session directly
<2> Use `@Transactional` for persist operations - creates new entities in the database
<3> Use `@Transactional` for update operations - modifies existing entities

The `@Transactional` interceptor will:

* Lazily open a Hibernate Reactive session when first accessed
* Begin a transaction automatically
* Commit the transaction when the method completes successfully
* Rollback the transaction if an exception is thrown or the `Uni` is cancelled
* Close the session and release the database connection when the reactive chain completes

[NOTE]
====
You can inject either `Mutiny.Session` or `Mutiny.StatelessSession`.
You must not inject both session types in the same bean. Attempting to use both session types within the same transaction will throw an `IllegalStateException`.
====

[IMPORTANT]
====
Currently, only `Transactional.TxType.REQUIRED` is supported with reactive transactions. Other transaction types (`REQUIRES_NEW`, `MANDATORY`, etc.) will throw an `UnsupportedOperationException`.
====

**Transaction Context Leakage with Declarative Transaction Management**

[WARNING]
====


When using declarative transaction management with Vert.x context-based interceptors (`@Transactional`, `@WithTransaction`, `@WithSession`, `@WithSessionOnDemand`) and combining transactional methods with non-transactional methods in parallel reactive chains (e.g., using `Uni.combine().all().unis()`), the transaction context may leak from the transactional method to the non-transactional method if they execute on the same Vert.x context.

This is a known limitation of declarative transaction management. A non-transactional method running in parallel with a declarative transactional method might inadvertently have access to the reactive session opened by the transactional method, leading to unexpected behavior.

====

**Workarounds**:

1. **Use programmatic transaction management**: Use `sessionFactory.withTransaction()` or `Panache.withTransaction()` instead of declarative annotations. Programmatic transaction management doesn't have this problem because you explicitly control where the transaction is created. Make sure you're actually using the session passed as a parameter and not the session injected via `@Inject`.
+
[source,java]
----
// SAFE: Programmatic transaction management
Uni.combine().all().unis(
    sessionFactory.withTransaction(session -> {
        // transactional work
    }),
    nonTransactionalMethod()
)
----

2. **Execute sequentially**: Ensure that transactional and non-transactional methods are not combined in parallel. Execute them sequentially instead.
+
[source,java]
----
// SAFE: Execute sequentially
transactionalMethod()
    .chain(() -> nonTransactionalMethod())
----

Example of problematic code:
[source,java]
----
// PROBLEMATIC: Transaction may leak to nonTransactionalMethod when using declarative @Transactional
Uni.combine().all().unis(
    transactionalMethod(),  // uses @Transactional
    nonTransactionalMethod()
)
----

[[hr-configuration-properties]]
=== Hibernate Reactive configuration properties

There are various optional properties useful to refine your session factory or guide Quarkus' guesses.

When no properties are set, Quarkus can typically infer everything it needs to set up Hibernate Reactive
and will have it use the default datasource.

The configuration properties listed here allow you to override such defaults, and customize and tune various aspects.

Hibernate Reactive uses the same properties you would use for Hibernate ORM: see <<configuration-reference>>.

[[orm-and-reactive-extension-simultaneously]]
=== Hibernate ORM and Reactive extensions simultaneously

If you add both Hibernate ORM and Hibernate Reactive extensions to your Quarkus app, they can be mixed together in the same project.

This is useful if your app normally uses Hibernate ORM (which is blocking), but you want to try Hibernate Reactive to see if it works better for your case.

By adding the second extension, you can use the reactive API in another part of your code - without needing to create a separate app.

NOTE: Hibernate ORM and Hibernate Reactive won't share the same persistence context, so it's recommended you stick to one or the other in a given method. For example use Hibernate ORM in blocking REST endpoints, and use Hibernate Reactive in reactive REST endpoints.

* To use the both extension simultaneously, add both extension to the `pom.xml` file:
+
[source,xml]
----
        <!-- Hibernate reactive -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-reactive</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-reactive-pg-client</artifactId>
        </dependency>

        <!-- Hibernate ORM -->
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-jdbc-postgresql</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-hibernate-orm</artifactId>
        </dependency>
----

* Also update the `applications.properties` file:
[source,properties]
----
%prod.quarkus.datasource.reactive.url=postgresql:///your_database
%prod.quarkus.datasource.jdbc.url=jdbc:postgresql://localhost:5432/hibernate_orm_test
----

* The presence of the JDBC driver will enable Hibernate ORM. If you want to disable it, and only use Hibernate Reactive, you can use:
+
[source,properties]
----
quarkus.hibernate-orm.blocking=false
----

Quarkus will set many Hibernate Reactive configuration settings automatically, and will often use more modern defaults.


[[hr-cdi-integration]]
==== CDI integration

If you are familiar with using Hibernate Reactive in Quarkus, you probably already have injected the `Mutiny.SessionFactory` using CDI:

[source,java]
----
@Inject
Mutiny.SessionFactory sessionFactory;
----

This will inject the `Mutiny.SessionFactory` of the default persistence unit.

NOTE: Prior to Quarkus 3.0 it was also possible to inject a `@RequestScoped` bean for `Mutiny.Session`. However, the lifecycle of a reactive session does not fit the lifecycle of the CDI request context. Therefore, this bean is removed in Quarkus 3.0.

[[persistence-unit-active]]
=== Activate/deactivate persistence units

When a persistence unit is configured at build time, and it is assigned entity types or an xref:datasource.adoc#datasource-active[active datasource], the persistence unit is active by default.
Quarkus starts the corresponding Hibernate Reactive `SessionFactory` when the application starts.

To deactivate a persistence unit at runtime, see xref:hibernate-orm.adoc#persistence-unit-active[the corresponding section of the Hibernate ORM guide].

[NOTE]
====
If you decide to follow the example from the Hibernate ORM guide to declare a custom CDI bean for the active persistence unit,
but you use Hibernate Reactive,
make sure to work with the `Mutiny.SessionFactory` type instead of `Session`:
this is one way Hibernate Reactive's API entrypoint differs from Hibernate ORM's.

See <<hr-cdi-integration>> for details.
====

[[flyway]]
== Automatically transitioning to Flyway to Manage Schemas

Hibernate Reactive can be used in the same application as Flyway.
See xref:flyway.adoc#reactive-datasources[this section of the Flyway extension documentation]
for details regarding configuration of Flyway in a reactive application.

[TIP]
====
If you have the xref:flyway.adoc[Flyway extension] installed when running in development mode,
Quarkus provides a simple way to initialize your Flyway configuration
using the schema generated automatically by Hibernate Reactive.

See xref:hibernate-orm.adoc#flyway[the Hibernate ORM guide] for more details.
====

[[testing]]
=== Testing

Using Hibernate Reactive in a `@QuarkusTest` is slightly more involved than using Hibernate ORM due to the asynchronous nature of the APIs and the fact that all operations need to run on a Vert.x Event Loop.

Two components are necessary to write these tests:

* The use of `@io.quarkus.test.vertx.RunOnVertxContext` or `@io.quarkus.test.TestReactiveTransaction` on the test methods
* The use of `io.quarkus.test.vertx.UniAsserter` as a test method parameter.

IMPORTANT: These classes are provided by the `quarkus-test-vertx` dependency.

A very simple example usage looks like:

[source,java]
----
@QuarkusTest
public class SomeTest {

    @Inject
    Mutiny.SessionFactory sessionFactory;

    @Test
    @RunOnVertxContext
    public void testQuery(UniAsserter asserter) {
        asserter.assertThat(() -> sessionFactory.withSession(s -> s.createQuery(
                "from Gift g where g.name = :name").setParameter("name", "Lego").getResultList()),
                list -> org.junit.jupiter.api.Assertions.assertEquals(list.size(), 1));
    }

}
----

NOTE: See the Javadoc of `UniAsserter` for a full description of the various methods that can be used for creating assertions.

[TIP]
====
You can also extend the `io.quarkus.test.vertx.UniAsserterInterceptor` to wrap the injected `UniAsserter` and customize the default behavior. For example, the interceptor can be used to execute the assert methods within a separate database transaction.:

[source,java]
----
@QuarkusTest
public class SomeTest {

   @Test
   @RunOnVertxContext
   public void testEntity(UniAsserter asserter) {
      asserter = new UniAsserterInterceptor(asserter) {
         @Override
         protected <T> Supplier<Uni<T>> transformUni(Supplier<Uni<T>> uniSupplier) {
            return () -> Panache.withTransaction(uniSupplier);
         }
      };
      asserter.execute(() -> new MyEntity().persist());
      asserter.assertEquals(() -> MyEntity.count(), 1l);
      asserter.execute(() -> MyEntity.deleteAll());
   }
}
----
====

[[multiple-persistence-units]]
=== Multiple persistence units

==== Setting up multiple persistence units

In a similar fashion to Hibernate ORM, Hibernate Reactive supports multiple persistence units.

You can define multiple persistence units and datasources, and they can mix blocking and reactive datasources.
To ensure that a datasource supports reactive, you need to set the `reactive` property to `true`.

[source,properties]
.Example `{config-file}`
----
quarkus.datasource."users".reactive.url=vertx-reactive:postgresql://localhost/users <1>
quarkus.datasource."users".db-kind=postgresql
%prod.quarkus.datasource."users".username=hibernate_orm_test
%prod.quarkus.datasource."users".password=hibernate_orm_test

quarkus.datasource."inventory".reactive.url=vertx-reactive:postgresql://localhost/inventory <2>
quarkus.datasource."inventory".db-kind=postgresql
%prod.quarkus.datasource."inventory".username=hibernate_orm_test
%prod.quarkus.datasource."inventory".password=hibernate_orm_test

quarkus.hibernate-orm."users".datasource=users <3>
quarkus.hibernate-orm."users".packages=io.quarkus.hibernate.reactive.multiplepersistenceunits.model.config.user

quarkus.hibernate-orm."inventory".datasource=inventory <4>
quarkus.hibernate-orm."inventory".packages=io.quarkus.hibernate.orm.multiplepersistenceunits.model.config.inventory
----
<1> Define a reactive datasource named `users`.
<2> Define a reactive datasource named `inventory`.
<3> Define a persistence unit named `users` and specify the datasource.
<4> Define a persistence unit named `inventory` and specify the datasource.

When using named persistence units, you must set the `datasource` property to the name of the corresponding datasource.

[[hr-limitations]]
== Limitations and other things you should know

Quarkus does not modify the libraries it uses; this rule applies to Hibernate Reactive as well: when using
this extension you will mostly have the same experience as using the original library.

But while they share the same code, Quarkus does configure some components automatically and inject custom implementations
for some extension points; this should be transparent and useful but if you're an expert of Hibernate Reactive you might want to
know what is being done.

Here's a list of things to pay attention when using Hibernate Reactive in Quarkus:

* Hibernate Reactive is not configurable via a `persistence.xml` file.
* This extension only considers the default persistence unit at the moment:
it's not possible to configure multiple persistence units,
or even a single named persistence unit.
* This extension does not support xref:hibernate-orm.adoc#database-approach[database-based multitenancy]
or xref:hibernate-orm.adoc#schema-approach[schema-based multitenancy] at the moment.
xref:hibernate-orm.adoc#discriminator-approach[Discriminator-based multitenancy], on the other hand, is expected to work correctly.
See https://github.com/quarkusio/quarkus/issues/15959.
* Integration with the Envers extension is not supported.

=== Transaction management: choosing between `@Transactional` and Panache annotations

With the introduction of the `quarkus-reactive-transactions` extension, you now have two options for managing transactions in Hibernate Reactive applications:

1. Use `jakarta.transaction.Transactional` for declarative transaction management
2. Use Panache's transaction annotations (`@WithTransaction`, `@WithSession`, `@WithSessionOnDemand`, or the programmatic `Panache.withTransaction()`)

Both approaches work with Panache entities. However, you must choose one approach and use it consistently throughout your application. Mixing both transaction management styles in the same application is not supported and will result in an `UnsupportedOperationException`.

== Simplifying Hibernate Reactive with Panache

The xref:hibernate-reactive-panache.adoc[Hibernate Reactive with Panache] extension facilitates the usage of Hibernate Reactive
by providing active record style entities (and repositories) and focuses on making your entities trivial and fun to write in Quarkus.

== Validation modes and Hibernate Validator integration

To find out more on how the <<quarkus-hibernate-orm_quarkus-hibernate-orm-validation-mode,`quarkus.hibernate-orm.validation.mode` configuration property>>.
influence your Hibernate Reactive application see the xref:hibernate-orm.adoc#validator_integration[corresponding Hibernate ORM guide],
as these modes work the same in both cases.

[[configuration-reference]]
== Configuration Reference for Hibernate Reactive

[TIP]
====
You will notice that some properties
contain "jdbc" in their name: this is because Hibernate ORM refers to its "data access" layer as "JDBC" for historical reasons. Hibernate Reactive uses Vert.x Reactive SQL clients for its data access layer rather than JDBC.

Regardless of their name, these properties still make sense for Hibernate Reactive.
====

include::{generated-dir}/config/quarkus-hibernate-orm.adoc[opts=optional, leveloffset=+2]
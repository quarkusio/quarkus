////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Quarkus - Elasticsearch
include::./attributes.adoc[]
:extension-status: preview

Elasticsearch is a well known full text search engine and NoSQL Database that is widely used.

In this guide, we wiil see how you can get your REST services to use Elasticsearch.

include::./status-include.adoc[]

== Prerequisites

To complete this guide, you need:

* less than 15 minutes
* an IDE
* JDK 1.8+ installed with `JAVA_HOME` configured appropriately
* Apache Maven {maven-version}
* Elasticsearch installed or Docker installed

== Architecture

The application built in this guide is quite simple: the user can add elements in a list using a form and the list is updated.

All the information between the browser and the server is formatted as JSON.

The elements are stored in Elasticsearch.

== Solution

We recommend that you follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone {quickstarts-clone-url}`, or download an {quickstarts-archive-url}[archive].

The solution is located in the `elasticsearch` {quickstarts-tree-url}/elasticsearch[directory].

== Creating the Maven project

First, we need a new project. Create a new project with the following command:

[source,shell,subs=attributes+]
----
mvn io.quarkus:quarkus-maven-plugin:{quarkus-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=elasticsearch-quickstart \
    -DclassName="org.acme.elasticsearch.FruitResource" \
    -Dpath="/fruits" \
    -Dextensions="resteasy-jackson,elasticsearch-low-level-client"
cd elasticsearch-quickstart
----

This command generates a Maven structure importing the RESTEasy/JAX-RS, Jackson, and Elasticsearch extensions.
After this, the quarkus-elasticsearch-low-level-client extension has been added to your `pom.xml`.

[NOTE]
====
We use the `resteasy-jackson` extension here and not the JSON-B variant because we will use the Vert.X `JsonObject` helper
to serialize/de-serialize our objects to/from Elasticsearch and it uses Jackson under the hood.
====


== Creating your first JSON REST service

In this example, we will create an application to manage a list of fruits.

First, let's create the `Fruit` bean as follows:

[source,java]
----
package org.acme.elasticsearch;

public class Fruit {
    public String id;
    public String name;
    public String color;
}
----

Nothing fancy. One important thing to note is that having a default constructor is required by the JSON serialization layer.

Now create a `org.acme.elasticsearch.FruitService` that will be the business layer of our application and store/load the fruits from the Elasticsearch database.

[source,java]
----
package org.acme.elasticsearch;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;

import org.apache.http.util.EntityUtils;
import org.elasticsearch.client.Request;
import org.elasticsearch.client.Response;
import org.elasticsearch.client.RestClient;

import io.vertx.core.json.JsonArray;
import io.vertx.core.json.JsonObject;

@ApplicationScoped
public class FruitService {
    @Inject
    RestClient restClient; //<1>

    public void index(Fruit fruit) throws IOException {
        Request request = new Request(
                "PUT",
                "/fruits/_doc/" + fruit.id); //<2>
        request.setJsonEntity(JsonObject.mapFrom(fruit).toString()); //<3>
        restClient.performRequest(request); //<4>
    }

    public Fruit get(String id) throws IOException {
        Request request = new Request(
                "GET",
                "/fruits/_doc/" + id);
        Response response = restClient.performRequest(request);
        String responseBody = EntityUtils.toString(response.getEntity());
        JsonObject json = new JsonObject(responseBody); //<5>
        return json.getJsonObject("_source").mapTo(Fruit.class);
    }

    public List<Fruit> searchByColor(String color) throws IOException {
        return search("color", color);
    }

    public List<Fruit> searchByName(String name) throws IOException {
        return search("name", name);
    }

    private List<Fruit> search(String term, String match) throws IOException {
        Request request = new Request(
                "GET",
                "/fruits/_search");
        String query = String.format("{\"query\": { \"match\": { \"%s\":\"%s\"}}}", term, match);
        request.setJsonEntity(query);
        Response response = restClient.performRequest(request);
        String responseBody = EntityUtils.toString(response.getEntity());
        System.out.println(responseBody);

        JsonObject json = new JsonObject(responseBody);
        JsonArray hits = json.getJsonObject("hits").getJsonArray("hits");
        List<Fruit> results = new ArrayList<>(hits.size());
        for (int i = 0; i < hits.size(); i++) {
            JsonObject hit = hits.getJsonObject(i);
            Fruit fruit = hit.getJsonObject("_source").mapTo(Fruit.class);
            results.add(fruit);
        }
        return results;
    }
}
----

In this example you can note the following:

1. We inject an Elasticsearch low level `RestClient` inside the service.
2. We create an Elasticsearch request.
3. We use Vert.X `JsonObject` to serialize the object before sending it to Elasticsearch, you can use whatever you want to serialize to JSON.
4. We send the request (indexing request here) to Elasticsearch.
5. In order to deserialize the object from Elasticsearch, we again use Vert.X `JsonObject`.

Now, edit the `org.acme.elasticsearch.FruitResource` class as follows:

[source,java]
----
@Path("/fruits")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class FruitResource {
    @Inject
    FruitService fruitService;

    @POST
    public Response index(Fruit fruit) throws IOException {
        if (fruit.id == null) {
            fruit.id = UUID.randomUUID().toString();
        }
        fruitService.index(fruit);
        return Response.created(URI.create("/fruits/" + fruit.id)).build();
    }

    @GET
    @Path("/{id}")
    public Fruit get(@PathParam("id") String id) throws IOException {
        return fruitService.get(id);
    }

    @GET
    @Path("/search")
    public List<Fruit> search(@QueryParam("name") String name, @QueryParam("color") String color) throws IOException {
        if (name != null) {
            return fruitService.searchByName(name);
        } else if (color != null) {
            return fruitService.searchByColor(color);
        } else {
            throw new BadRequestException("Should provide name or color query parameter");
        }
    }

}
----

The implementation is pretty straightforward and you just need to define your endpoints using the JAX-RS annotations and use the `FruitService` to list/add new fruits.

== Configuring Elasticsearch
The main property to configure is the URL to access to Elasticsearch.

A sample configuration should look like this:

[source,properties]
----
# configure the Elasticsearch client to a cluster of two nodes
quarkus.elasticsearch.hosts = elasticsearch1:9200,elasticsearch2:9200
----

In this example, we are using a single instance running on localhost:

[source,properties]
----
# configure the mongoDB client for a single instance on localhost
quarkus.elasticsearch.hosts = localhost:9200
----

If you need more configuration properties, there is a full list at the end of this guide.


== Running an Elasticsearch
As by default, the `RestClient` is configured to access a local Elasticsearch on port 9200 (the default Elasticsearch port),
if you have a local running database on this port, there is nothing more to do before being able to test it!

If you want to use Docker to run an Elasticsearch database, you can use the following command to launch one:
[source,shell]
----
docker run --name elasticsearch  -e "discovery.type=single-node" -e "ES_JAVA_OPTS=-Xms512m -Xmx512m"\
       --rm -p 9200:9200 docker.elastic.co/elasticsearch/elasticsearch-oss:7.6.0
----

== Creating a frontend

Now let's add a simple web page to interact with our `FruitResource`.
Quarkus automatically serves static resources located under the `META-INF/resources` directory.
In the `src/main/resources/META-INF/resources` directory, add a `fruits.html` file with the content from this {quickstarts-blob-url}/elasticsearch-quickstart/src/main/resources/META-INF/resources/fruits.html[fruits.html] file in it.

You can now interact with your REST service:

* start Quarkus with `./mvnw compile quarkus:dev`
* open a browser to `http://localhost:8080/fruits.html`
* add new fruits to the list via the 'Add fruit' form
* search for fruits by name or color via the 'Search Fruit' form

== What about the Elasticsearch High Level Rest client

Quarkus didn't provide support for the Elasticsearch High Level RestClient as this client comes with some caveats:

- It contains a lot of dependencies, which didn't fit well inside Quarkus philosophy.
- It is tied to a certain version of the Elasticsearch server: you cannot use a High Level RestClient version 7 to access a server version 6.

== Hibernate Search Elasticsearch

Quarkus support Hibernate Search with Elasticsearch via the `hibernate-search-elasticsearch` extension.

Hibernate Search Elasticsearch allow to synchronize your JPA entities to an Elasticsearch and offer a way to query your Elasticsearch cluster using the Hibernate Search API.

If you're interested in it, you can read the link:hibernate-search-elasticsearch[Hibernate Search Elasticsearch guide].

== Cluster Health Check

If you are using the `quarkus-smallrye-health` extension, `quarkus-elasticsearch-low-level-client` will automatically add a readiness health check
to validate the health of the cluster.

So when you access the `/health/ready` endpoint of your application you will have information about the cluster status.
It uses the cluster health endpoint, the check will be down if the status of the cluster is **red**, or the cluster is not available.

This behavior can be disabled by setting the `quarkus.elasticsarch.health.enabled` property to `false` in your `application.properties`.

== Building a native executable

You can use the Elasticsearch low level client in a native executable.

You can build a native executable with the usual command `./mvnw package -Pnative`.

Running it is as simple as executing `./target/elasticsearch-quickstart-1.0-SNAPSHOT-runner`.

You can then point your browser to `http://localhost:8080/fruits.html` and use your application.

== Conclusion

Accessing an Elasticsearch database from a MongoDB Client is easy with Quarkus as it provides configuration and native support for it.

== Configuration Reference

include::{generated-dir}/config/quarkus-elasticsearch.adoc[opts=optional, leveloffset=+1]

= {project-name} - Using JSON and Validation

JSON is now the _lingua franca_ between microservices.
In this guide, we see how you can consume and produce JSON payloads.
The guide also covers how to validate JSON payloads.

== Prerequisites

To complete this guide, you need:

* less than 15 minutes
* an IDE
* JDK 1.8+ installed with `JAVA_HOME` configured appropriately
* Apache Maven 3.5+

== Architecture

The application built in this guide is quite simple. The user fills a form on a web page.
The web page sends the form content to the `BookResource` as JSON (using Ajax). The `BookResource` validates the user input and returns the
_result_ as JSON.

image:validation-guide-architecture.png[alt=Architecture,width=640,height=480]

== Solution

We recommend you to follow the instructions in the next sections and create the application step by step.
However, you can go right to the completed example.

Clone the Git repository: `git clone https://github.com/protean-project/quickstarts.git`, or download an https://github.com/protean-project/quickstarts/archive/master.zip[archive].

The solution is located in the `input-validation` https://github.com/protean-project/quickstarts/tree/master/input-validation[directory].

== Creating the Maven project

First, we need a new project. Create a new project with the following command:

[source, subs=attributes+]
----
mvn org.jboss.shamrock:shamrock-maven-plugin:{shamrock-version}:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=input-validation \
    -DclassName="org.acme.validation.BookResource" \
    -Dextensions="json, validation"
----

This command generates a Maven structure importing the JSON and validation support.

== Accessing the Validator

Edit the `org.acme.validation.BookResource` class, and inject the `Validator` object as follows:

[source,java]
----
@Inject
Validator validator;
----

The `Validator` allows checking constraints on a specific object.

== Constraints

In this application, we are going to test an elementary object, but we support complicated constraints and can validate graphs of objects.
Create the `org.acme.validation.Book` class with the following content:

[source, java]
----
package org.acme.validation;

import javax.validation.constraints.*;

public class Book {

    @NotBlank(message="Title may not be blank")
    private String title;

    @NotBlank(message="Author may not be blank")
    private String author;

    @Min(message="Author has been very lazy", value=1)
    private double pages;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    public double getPages() {
        return pages;
    }

    public void setPages(double pages) {
        this.pages = pages;
    }
}
----

Constraints are added on fields, and when an object is validated, the values are checked.
The getter and setter methods are also used for JSON mapping.

== JSON mapping and validation

Back to the `BookResource` class.
Add the following method:

[source, java]
----
@Path("/manual-validation")
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Result tryMeManualValidation(Book book) {
    Set<ConstraintViolation<Book>> violations = validator.validate(book);
    if (violations.isEmpty()) {
        return new Result("Book is valid! It was validated by manual validation.");
    } else {
        return new Result(violations);
    }
}
----

Yes it does not compile, `Result` is missing, but we will add it very soon.
First, let's explain this method.
It indicates it consumes and produces JSON.
The method parameter (`book`) is created from the JSON payload automatically.

The method uses the `Validator` to check the payload.
It returns a set of violations.
If this set is empty, it means the object is valid.
In case of failures, the messages are concatenated and sent back to the browser.

Let's now create the `Result` class as an inner class:

[source, java]
----
private class Result {
        
    Result(String message) {
        this.success = true;
        this.message = message;
    }
        
    Result(Set<? extends ConstraintViolation<?>> violations) {
        this.success = false;
        this.message = violations.stream()
             .map(cv -> cv.getMessage())
             .collect(Collectors.joining(", "));
    }

    private String message;
    private boolean success;

    public String getMessage() {
        return message;
    }

    public boolean isSuccess() {
        return success;
    }

}
----

The class is very simple and only contains 2 fields and the associated getters and setters.
Because we indicate that we produce JSON, the mapping to JSON is made automatically.

== REST end point validation

While using the `Validator` manually might be useful for some advanced usage,
if you simply want to validate the parameters or the return value or your REST end point,
you can annotate it directly, either with constraints (`@NotNull`, `@Digits`...)
or with `@Valid` (which will cascade the validation to the bean).

Let's create an end point validating the `Book` provided in the request:

[source, java]
----
@Path("/end-point-method-validation")
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Result tryMeEndPointMethodValidation(@Valid Book book) {
    return new Result("Book is valid! It was validated by end point method validation.");
}
----

As you can see, we don't have to manually validate the provided `Book` anymore as it is automatically validated.

If a validation error is triggered, a violation report is generated and serialized as JSON as our end point produces a JSON output.
It can be extracted and manipulated to display a proper error message.

== Service method validation

It might not always be handy to have the validation rules declared at the end point level as it could duplicate some business validation.

The best option is then to annotate a method of your business service with your constraints (or in our particular case with `@Valid`):

[source, java]
----
@ApplicationScoped
public class BookService {

    public void validateBook(@Valid Book book) {
        // your business logic here
    }
}
----

Calling the service in your rest end point triggers the `Book` validation automatically:

[source, java]
----
@Path("/service-method-validation")
@POST
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Result tryMeServiceMethodValidation(Book book) {
    try {
        bookService.validateBook(book);
        return new Result("Book is valid! It was validated by service method validation.");
    } catch (ConstraintViolationException e) {
        return new Result(e.getConstraintViolations());
    }
}
----

Note that, if you want to push the validation errors to the frontend, you have to catch the exception and push the information yourselves
as they will not be automatically pushed to the JSON output.

Keep in mind that you usually don't want to expose to the public the internals of your services
- and especially not the validated value contained in the violation object.

== A frontend

Now let's add the simple web page to interact with our `BookResource`.
Shamrock automatically serves static resources contained in the `META-INF/resources` directory.
Creates the `src/main/resources/META-INF/resources` directory and copy this https://github.com/protean-project/quickstarts/blob/master/input-validation/src/main/resources/META-INF/resources/index.html[index.html] file in it.

== Run the application

Now, let's see our application in action. Run it with:

```
mvn compile shamrock:dev
```

Then, open your browser to http://localhost:8080/:

1. Enter the book details (valid or invalid)
2. Click on the _Try me..._ buttons to check if your data is valid using one of the methods we presented above.

image:validation-guide-screenshot.png[alt=Application,width=800]

As usual, the application can be packaged using `mvn clean package` and executed using the `-runner.jar` file.
You can also build the native executable using `mvn package -Pnative`.
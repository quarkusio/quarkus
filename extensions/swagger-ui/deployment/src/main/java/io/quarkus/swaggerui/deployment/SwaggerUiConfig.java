package io.quarkus.swaggerui.deployment;

import java.net.URI;
import java.util.Comparator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.Set;
import java.util.TreeMap;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;

import io.quarkus.runtime.annotations.ConfigGroup;
import io.quarkus.runtime.annotations.ConfigItem;
import io.quarkus.runtime.annotations.ConfigRoot;
import io.vertx.core.http.HttpMethod;

/**
 * Please @see <a href="https://swagger.io/docs/open-source-tools/swagger-ui/usage/configuration">Swagger UI documentation</a>
 */
@ConfigRoot
class SwaggerUiConfig {

    /**
     * If Swagger UI should be enabled. By default, Swagger UI is enabled.
     */
    @ConfigItem(defaultValue = "true")
    boolean enable;

    /**
     * The path where Swagger UI is available.
     * <p>
     * The value `/` is not allowed as it blocks the application from serving anything else.
     */
    @ConfigItem(defaultValue = "/swagger-ui")
    String path;

    /**
     * If this should be included every time. By default, this is only included when the application is running
     * in dev mode.
     */
    @ConfigItem
    boolean alwaysInclude;

    /**
     * URI to fetch external configuration document from.
     */
    @ConfigItem
    Optional<URI> configUrl;

    /**
     * Enables deep linking for tags and operations.
     *
     * Please @see <a href="https://swagger.io/docs/open-source-tools/swagger-ui/usage/deep-linking">Swagger UI deep linking
     * documentation</a>
     */
    @ConfigItem
    boolean deepLinking;

    /**
     * The default expansion depth for models (set to -1 completely hide the models).
     */
    @ConfigItem(defaultValue = "1")
    int defaultModelsExpandDepth;

    /**
     * The default expansion depth for the model in the model-example section.
     */
    @ConfigItem(defaultValue = "1")
    int defaultModelExpandDepth;

    /**
     * Controls how the model is shown when the API is first rendered.
     */
    @ConfigItem(defaultValue = "EXAMPLE")
    Rendering defaultModelRendering;

    /**
     * Controls the display of operationId in operations list.
     */
    @ConfigItem
    boolean displayOperationId;

    /**
     * Controls the display of the request duration (in milliseconds) for Try-It-Out requests.
     */
    @ConfigItem
    boolean displayRequestDuration;

    /**
     * Controls the default expansion setting for the operations and tags.
     */
    @ConfigItem(defaultValue = "LIST")
    Expansion docExpansion;

    /**
     * If set, enables filtering. The top bar will show an edit box that could be used to filter
     * the tagged operations that are shown.
     */
    @ConfigItem
    boolean filter;
    /**
     * The name of a component available via the plugin system to use as the top-level layout for Swagger UI.
     */
    @ConfigItem(defaultValue = "StandaloneLayout")
    String layout;

    /**
     * If set, limits the number of tagged operations displayed to at most this many.
     */
    @ConfigItem
    OptionalInt maxDisplayedTags;

    /**
     * Controls the display of vendor extension (x-) fields and values.
     */
    @ConfigItem
    boolean showExtensions;

    /**
     * Controls the display of extensions.
     */
    @ConfigItem
    boolean showCommonExtensions;

    /**
     * The supported try it out methods.
     */
    @ConfigItem
    Optional<List<HttpMethod>> supportedSubmitMethods;

    /**
     * Apply a sort to the operation list of each API.
     */
    @ConfigItem
    Optional<Sort> operationsSorter;

    /**
     * Apply a sort to the tag list of each API.
     */
    @ConfigItem
    Optional<Sort> tagsSorter;

    /**
     * The url pointing to API definition (the default points to the URI generated by the OpenAPI extension).
     */
    @ConfigItem
    Optional<URI> url;

    /**
     * The order of the swagger groups which will be displayed when Swagger UI loads.
     */
    @ConfigItem(defaultValue = "ASC")
    Order groupsOrder;

    /**
     * When used and Topbar plugin is enabled, the url parameter will not be parsed.
     * Names and URLs must be unique among all items in this array, since they're used as identifiers.
     * SpecGroupUrl must match the pattern: <url>?group=<name>
     */
    @ConfigItem
    Optional<Set<SpecGroupUrl>> urls;

    /**
     * The name of the swagger group which will be displayed when Swagger UI loads.
     */
    @ConfigItem
    Optional<String> urlsPrimaryName;

    /**
     * Set a different validator URL, for example for locally deployed validators.
     */
    @ConfigItem
    Optional<URI> validatorUrl;

    /**
     * OAuth redirect URL.
     */
    @ConfigItem
    Optional<String> oauth2RedirectUrl;

    /**
     * OAuth configuration.
     */
    OAuthConfig oauth;

    public Map<String, Object> getSwaggerUiProps(final String openApiPath) {
        updateApiUrl(openApiPath);
        updateAuthUrl();
        updateLayout();
        return getProps();
    }

    private Map<String, Object> getProps() {
        Map<String, Object> props = new TreeMap<>();
        props.put("deepLinking", deepLinking);
        props.put("defaultModelExpandDepth", defaultModelExpandDepth);
        props.put("defaultModelRendering", defaultModelRendering.toString().toLowerCase());
        props.put("defaultModelsExpandDepth", defaultModelsExpandDepth);
        props.put("displayOperationId", displayOperationId);
        props.put("displayRequestDuration", displayRequestDuration);
        props.put("docExpansion", docExpansion.toString().toLowerCase());
        props.put("dom_id", "#swagger-ui");
        props.put("filter", filter);
        maxDisplayedTags.ifPresent(i -> props.put("maxDisplayedTags", i));
        props.put("layout", layout);
        oauth2RedirectUrl.ifPresent(s -> props.put("oauth2RedirectUrl", s));
        operationsSorter.ifPresent(s -> props.put("operationsSorter", s.toString().toLowerCase()));
        props.put("showCommonExtensions", showCommonExtensions);
        props.put("showExtensions", showExtensions);
        supportedSubmitMethods.ifPresent(ls -> props.put("supportedSubmitMethods", getSupportedSubmitMethods(ls)));
        tagsSorter.ifPresent(s -> props.put("tagsSorter", s.toString().toLowerCase()));
        url.ifPresent(s -> props.put("url", s));
        url.ifPresent(s -> props.put("url", s));
        urls.ifPresent(sgu -> props.put("urls", getSpecGroupUrls(sgu)));
        urlsPrimaryName.ifPresent(s -> props.put("urls.primaryName", s));
        validatorUrl.ifPresent(s -> props.put("validatorUrl", s));
        return props;
    }

    private void updateApiUrl(String openApiPath) {
        if (!StringUtils.isEmpty(openApiPath)) {
            final Optional<URI> openApiUri = Optional.of(URI.create(openApiPath));
            if (!this.url.isPresent()) {
                this.url = openApiUri;
            }
        }
    }

    private void updateAuthUrl() {
        if (this.oauth.enable && !this.oauth2RedirectUrl.isPresent()) {
            this.oauth2RedirectUrl = Optional.of(this.path + "/oauth2-redirect.html");
        }
    }

    private void updateLayout() {
        if (this.urls.isPresent() && this.layout.equals("BaseLayout")) {
            this.layout = "StandaloneLayout";
        }
    }

    private List<String> getSupportedSubmitMethods(List<HttpMethod> supportedSubmitMethods) {
        return supportedSubmitMethods.stream()
                .filter(Objects::nonNull)
                .map(Enum::name)
                .map(String::toLowerCase)
                .collect(Collectors.toList());
    }

    enum Expansion {
        LIST,
        FULL,
        NONE
    }

    enum Rendering {
        EXAMPLE,
        MODEL
    }

    enum Sort {
        ALPHA,
        METHOD
    }

    enum Order {
        ASC,
        DESC;

        public boolean isAscending() {
            return this.equals(ASC);
        }
    }

    private Set<SpecGroupUrl> getSpecGroupUrls(Set<SpecGroupUrl> specGroupUrls) {
        Comparator<SpecGroupUrl> specGroupUrlComparator;
        if (groupsOrder.isAscending()) {
            specGroupUrlComparator = Comparator.comparing(SpecGroupUrl::getName);
        } else {
            specGroupUrlComparator = (url1, url2) -> url2.getName().compareTo(url1.getName());
        }

        return specGroupUrls.stream()
                .sorted(specGroupUrlComparator)
                .filter(specGroupUrl -> StringUtils.isNotEmpty(specGroupUrl.getUrl().toString()))
                .collect(Collectors.toCollection(LinkedHashSet::new));

    }

    public static class SpecGroupUrl {

        URI url;
        String name;

        public SpecGroupUrl() {
        }

        public SpecGroupUrl(String specGroup) {
            Objects.requireNonNull(specGroup, "specGroup cannot be null");
            if (specGroup.contains("?group=")) {
                String[] args = specGroup.trim().split("\\?group=");
                if (args.length == 2) {
                    this.url = URI.create(args[0]);
                    this.name = args[1];
                } else {
                    throw new IllegalArgumentException(
                            "Error, expected arguments number to be 2, but found: " + args.length +
                                    ", " + specGroup + " must match the pattern: <url>?group=<name>");
                }
            } else {
                throw new IllegalArgumentException(specGroup + " doesn't match the pattern: <url>?group=<name>");
            }
        }

        public URI getUrl() {
            return url;
        }

        public void setUrl(URI url) {
            this.url = url;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o)
                return true;
            if (o == null || getClass() != o.getClass())
                return false;
            SpecGroupUrl that = (SpecGroupUrl) o;
            return name.equals(that.name);
        }

        @Override
        public int hashCode() {
            return Objects.hash(name);
        }

        @Override
        public String toString() {
            return "SwaggerUrl{" + "url='" + url + '\'' +
                    ", name='" + name + '\'' +
                    '}';
        }
    }

    /**
     * Please @see <a href="https://swagger.io/docs/open-source-tools/swagger-ui/usage/oauth2">Swagger UI OAuth 2.0
     * documentation</a>
     */
    @ConfigGroup
    public static class OAuthConfig {

        /**
         * Indicates whether to setup OAuth 2.0
         */
        @ConfigItem
        boolean enable;

        /**
         * Application name, displayed in authorization popup. MUST be a string.
         */
        @ConfigItem
        Optional<String> appName;

        /**
         * Default clientId. MUST be a string.
         */
        @ConfigItem
        Optional<String> clientId;

        /**
         * Never use this parameter in your production environment. It exposes cruicial security information.
         * This feature is intended for dev/test environments only.
         * Default clientSecret. MUST be a string
         */
        @ConfigItem
        Optional<String> clientSecret;

        /**
         * Realm query parameter (for oauth1) added to authorizationUrl and tokenUrl. MUST be a string.
         */
        @ConfigItem
        Optional<String> realm;

        /**
         * Scope separator for passing scopes, encoded before calling, default value is a space (encoded value %20).
         * MUST be a string.
         */
        @ConfigItem
        Optional<String> scopeSeparator;

        /**
         * Additional query parameters added to authorizationUrl and tokenUrl. MUST be an object.
         */
        @ConfigItem
        Map<String, String> additionalQueryStringParams;

        /**
         * Only activated for the accessCode flow. During the authorization_code request to the tokenUrl,
         * pass the Client Password using the HTTP Basic Authentication scheme
         * (Authorization header with Basic base64encode(client_id + client_secret)). The default is false.
         */
        @ConfigItem
        boolean useBasicAuthenticationWithAccessCodeGrant;

        /**
         * Only applies to authorizatonCode flows.
         * Proof Key for Code Exchange brings enhanced security for OAuth public clients. The default is false.
         */
        @ConfigItem
        boolean usePkceWithAuthorizationCodeGrant;

        public Map<String, Object> getConfigParameters() {
            final Map<String, Object> params = new TreeMap<>();
            clientId.ifPresent(s -> params.put("clientId", s));
            clientSecret.ifPresent(s -> params.put("clientSecret", s));
            realm.ifPresent(s -> params.put("realm", s));
            appName.ifPresent(s -> params.put("appName", s));
            scopeSeparator.ifPresent(s -> params.put("scopeSeparator", s));
            params.put("additionalQueryStringParams", additionalQueryStringParams);
            params.put("useBasicAuthenticationWithAccessCodeGrant", useBasicAuthenticationWithAccessCodeGrant);
            params.put("usePkceWithAuthorizationCodeGrant", usePkceWithAuthorizationCodeGrant);
            return params;
        }
    }
}

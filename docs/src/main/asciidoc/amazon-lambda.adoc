////
This guide is maintained in the main Quarkus repository
and pull requests should be submitted there:
https://github.com/quarkusio/quarkus/tree/master/docs/src/main/asciidoc
////
= Quarkus - Amazon Lambda

include::./attributes.adoc[]


The `quarkus-amazon-lambda` extension allows you to use Quarkus to build your Amazon Lambdas.
Your lambdas can use injection annotations from CDI or Spring and other Quarkus facilities as you need them.

Quarkus lambdas can be deployed using the Amazon Java Runtime, or you can build a native executable and use
Amazon's Custom Runtime if you want a smaller memory footprint and faster cold boot startup time.

== Prerequisites

To complete this guide, you need:

* less than 30 minutes
* JDK 1.8 (AWS requires JDK 1.8)
* Apache Maven 3.5.3+
* https://aws.amazon.com[An Amazon AWS account]
* https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html[AWS CLI]
* https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI], for local testing

== Getting Started

This guide walks you through generating an example Java project via a maven archetype and deploying it to AWS.

== Installing AWS bits

Installing all the AWS bits is probably the most difficult thing about this guide.  Make sure that you follow all the steps
for installing AWS CLI.

== Creating the Maven Deployment Project

Create the Quarkus AWS Lambda maven project using our Maven Archetype.


[source, subs=attributes+]
----
mvn archetype:generate \
       -DarchetypeGroupId=io.quarkus \
       -DarchetypeArtifactId=quarkus-amazon-lambda-archetype \
       -DarchetypeVersion={quarkus-version}
----

== Choose Your Lambda

The `quarkus-amazon-lambda` extension scans your project for a class that implements the Amazon `RequestHandler` interface.
It must find a class in your project that implements this interface or it will throw a build time failure.
If it finds more than one handler class, a build time exception will also be thrown.

Sometimes, though, you might have a few related lambdas that share code and creating multiple maven modules is just
an overhead you don't want to do.  The `quarkus-amazon-lambda` extension allows you to bundle multiple lambdas in one
project and use configuration or an environment variable to pick the handler you want to deploy.

The generated project has two lambdas within it.  One that is used and one that is unused.  If you open up
`src/main/resources/application.properties` you'll see this:

[source, subs=attributes+]
----
quarkus.lambda.handler=test
----

The `quarkus.lambda.handler` property tells Quarkus which lambda handler to deploy. This can be overridden
with an environment variable too.

If you look at the two generated handler classes in the project, you'll see that they are `@Named` differently.

[source, subs=attributes+]
----
@Named("test")
public class TestLambda implements RequestHandler<InputObject, OutputObject> {

}

@Named("unused")
public class UnusedLambda implements RequestHandler<InputObject, OutputObject> {

}
----

The CDI name of the handler class must match the value specified within the `quarkus.lambda.handler` property.


== Deploy to AWS Lambda Java Runtime

There are a few steps to get your lambda running on AWS.  The generated maven project contains some helpful scripts to
create, update, delete, and invoke your lambdas for pure Java and native deployments.

== Build and Deploy

Build the project using maven.

[source, subs=attributes+]
----
mvn clean install
----

This will compile and package your code.

== Create an Execution Role

View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying
a lambda with AWS CLI.  Specifically, make sure you have created an `Execution Role`.  You will need to copy and
paste the `Role Arn` into the scripts generated by the maven archetype.

== Edit Script Files

Edit the `create.sh` and `create-native.sh` scripts included with the generated project.  After the `--role` switch
replace the dummy `Role Arn` with the Arn of the `Execution Role` you created in the Amazon IAM console.

== Create the function

The `create.sh` script is for deploying your lambda using the AWS Lambda Java runtime.

.create.sh
[source, subs=attributes+]
----
aws lambda create-function --function-name my-function \
           --zip-file fileb://target/my-function-1.0-SNAPSHOT-runner.jar \
           --handler io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest \
           --runtime java8 \
           --role arn:aws:iam::1234567:role/lambda-cli-role
----

Don't forget to replace the `--role` flag with the Arn of your `Execution Role`.

WARNING: Do not change the handler switch.  This must be hardcoded to `io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest`.  This
handler bootstraps Quarkus and wraps your actual handler so that injection can be performed.

If there are any problems creating the function, you must delete it with the `delete.sh` script before re-running
the `create.sh` script.

== Invoke the Lambda

Use the `invoke.sh` script to invoke your function.

.invoke.sh
[source, subs=attributes+]
----
aws lambda invoke --function-name my-function
                  --payload file://payload.json out
                  --log-type Tail --query 'LogResult' --output text |  base64 -d
----

The example lambda takes input passed in via the `--payload` switch which points to a json file
in the root directory of the project.  If you want to see the return output of the lambda, open the `out` file.
This script will also write the log output to the console.

== Update the Lambda

You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the
`update.sh` script.

.update.sh
[source, subs=attributes+]
----
aws lambda update-function-code --function-name my-function \
           --zip-file fileb://target/my-function-1.0-SNAPSHOT-runner.jar
----

== Deploy to AWS Lambda Custom (native) Runtime

If you want a lower memory footprint and faster initialization times for your lambda, you can compile your Java
code to a native executable.  Just make sure to rebuild your project with the `-Dnative` switch.

== Build and Deploy (native)

Build the native executable.

[source, subs=attributes+]
----
mvn clean install -Dnative
----

This will compile and create a native executable image.  It also generates a zip file `target/function.zip`.
This zip file contains your native executable image renamed to `bootstrap`.  This is a requirement of Amazon Lambda
Custom Runtime.


== Create an Execution Role

View the https://docs.aws.amazon.com/lambda/latest/dg/gettingstarted-awscli.html[Getting Started Guide] for deploying
a lambda with AWS CLI.  Specifically make sure you have created an `Execution Role`.  You will need the `Role Arn` to copy/paste
into the scripts generated by the maven archetype.

== Edit native script files

Edit the `create-native.sh` scripts included with the generated project.  After the `--role` switch
replace the dummy `Role Arn` with the Arn of the `Execution Role` you created in the Amazon IAM console.

== Create the Native Lambda

The `create-native.sh` script is for deploying your lambda using the AWS Lambda Custom runtime.

.create-native.sh
[source, subs=attributes+]
----
aws lambda create-function --function-name my-native-function \
           --zip-file fileb://target/function.zip --handler any.name.not.used \
           --runtime provided --role arn:aws:iam::1234567:role/lambda-cli-role \
           --environment Variables="{DISABLE_SIGNAL_HANDLERS=true}"
----

Don't forget to replace the `--role` flag with the Arn of your `Execution Role`.

Notice that the `--zip-file` flag points to the `function.zip` file generated by the build.
The handler switch is not used, but must be set.  It can be any value.  Finally, notice that an environment variable
must be set: `DISABLE_SIGNAL_HANDLERS`.  This resolves certain incompatibilities with the Amazon Lambda Custom Runtime container
and Quarkus.

If there are any problems creating the function, you must delete it with the `delete-native.sh` script before re-running
the `create-native.sh` script.

== Invoke the Native Lambda

Use the `invoke-native.sh` script to invoke your function.

.invoke-native.sh
[source, subs=attributes+]
----
aws lambda invoke --function-name my-native-function
                  --payload file://payload.json out
                  --log-type Tail --query 'LogResult' --output text |  base64 -d
----

The example lambda takes input.  This input is passed in via the `--payload` switch which points to a json file
in the root directory of the project.  If you want to see the return output of the lambda, open the `out` file.
This script will also write the log output to the console.

== Update the Native Lambda

You can update the Java code as you see fit.  Once you've rebuilt, you can redeploy your lambda by executing the
`update-native.sh` script.

.update-native.sh
[source, subs=attributes+]
----
aws lambda update-function-code --function-name my-native-function \
           --zip-file fileb://target/function.zip
----

== Examine the POM

If you want to adapt an existing project to use Quarkus's Amazon Lambda extension, there's a couple
of things you need to do.  Take a look at the generated example project to get an example of what you need to adapt.

1. Include the `quarkus-amazon-lambda` extension as a pom dependency
2. Configure Quarkus to build an `uber-jar` (via quarkus.package.uber-jar=true in the application.properties)
3. If you are doing a native image build, Amazon requires you to rename your executable to `bootstrap` and zip it up.  Notice that the `pom.xml` uses the `maven-assembly-plugin` to perform this requirement.

NB: With gradle, to build the uber-jar execute: ./gradlew quarkusBuild --uber-jar

== Testing with the SAM CLI

The https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-cli-install.html[AWS SAM CLI] allows you to run your lambdas locally on your laptop in a simulated Lambda environment.  This requires https://www.docker.com/products/docker-desktop[docker] to be installed.

To execute your lambda function with the
`java8` runtime, create a `sam.jvm.yaml` template as below:
----
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Globals:
  Function:
    Timeout: 5
Resources:
  QuarkusSam:
    Type: AWS::Serverless::Function
    Properties:
      Handler: io.quarkus.amazon.lambda.runtime.QuarkusStreamHandler::handleRequest
      Runtime: java8
      CodeUri: {path to *-runner.jar}
      MemorySize: 128
      Policies: AWSLambdaBasicExecutionRole
----

Run the following SAM CLI command to test your lambda function with the `Java8` runtime and `sam.jvm.yaml` template:
----
sam local invoke --template sam.jvm.yaml --event {json test file}
----

The native executable can be tested via the `provided` runtime defined in a `sam.native.yaml` template:
----
AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31

Globals:
  Function:
    Timeout: 5
Resources:
  QuarkusSam:
    Type: AWS::Serverless::Function
    Properties:
      Handler: not.used.in.provided.runtimei
      Runtime: provided
      CodeUri: {path to function.zip}
      MemorySize: 128
      Policies: AWSLambdaBasicExecutionRole
      Timeout: 15
      Environment:
        Variables:
          DISABLE_SIGNAL_HANDLERS: true
----


When using the `provided` runtime, AWS requires a bootstrap script to trigger the native executable. Bundle the `bootstrap` script along with the *-runner executable.

i.e., create a zip file called `function.zip` with:

* bootstrap
* {projectname-version}-runner

Example `bootstrap` script to load the native executable:
----
#!/usr/bin/env bash

RUNNER=$( find . -maxdepth 1 -name '*-runner' )
if [[ ! -z "$RUNNER" ]]
then
    $RUNNER
fi
----

To invoke the native `provided` runtime with the `sam.native.yaml` template, use the following command:

----
sam local invoke --template sam.native.yaml --event {json test file}
----
= Extension Structure Guidelines

* Status: Proposed
* Date: 2025-07-25
* Authors: @cescoffier, @gsmet

== Context

The Quarkus ecosystem includes more than 700 extensions, many of which were developed without a consistent structure.
The Quarkus core repository alone contains over 150 extensions.

Most extensions follow the basic runtime/deployment split, but the boundaries between API and internal logic have often blurred.
Additionally, without clear package structure rules, many split packages have emerged.
This situation introduces several issues:

* It is unclear which classes are intended as public APIs versus internal implementations.
* There is no clear boundary between what an extension consumer can depend on and what they should not use.
* Some extensions mix SPI and implementation code, reducing modularity and increasing the chance of unwanted coupling.
* The need for build item re-use or coordination between extensions leads to ad-hoc patterns.
* The word _deployment_ is there for historic reasons, but does not make a lot of sense. `build` would be better.

More recently, we introduced dev-only modules, further increasing complexity.

To address these issues and prepare for long-term maintainability (and possibly Java Platform Module System (JPMS) adoption), we propose a more structured layout for extension modules.

== Decision

Extensions may adopt a standardized structure, composed of one mandatory and several optional modules, depending on their complexity and integration needs:

* `runtime`: Contains the runtime implementation.
It may expose public APIs if needed but should prefer delegation to the `runtime-api` module (See <<the-place-of-the-public-api>>).
This module also contains the `recorders` and other runtime logic.
* `runtime-api`: Contains public APIs intended to be consumed by other extensions or application code.
This module should have minimal dependencies.
Depending on an `runtime-api` module does not transitively include the full extension (i.e., it avoids pulling in runtime or build logic). See <<coupling-api-and-spi>> for more details.
* `build`: Contains build-time logic, including `BuildSteps`.
This module may define internal build items.
* `build-spi`: Contains build-time APIs intended to be reused across multiple extensions for integration purposes.
Extensions contributing to or using build items from other extensions should depend on `build-spi` modules.
* `dev`: Contains runtime classes used exclusively in dev mode (e.g., for the Dev UI). This avoids shipping dev-only classes into production artifacts.
* `codestart`: Contains the _Codestart_ templates for the extension. See https://quarkus.io/guides/extension-codestart[Codestart Guide] for more details.
* `cli`: Contains CLI commands related to the extension. This is optional and should be used only if the extension provides specific CLI functionality.
* `codegen`: Contains code generation utilities such as code pre-processors invoked at build time.

Only the `runtime` and `build` modules are mandatory; the others are optional based on the extension's needs.


.New structure for Quarkus extensions
[source,tree]
----
my-extension/
├── runtime/
├── runtime-api/
├── build/
├── build-spi/
├── dev/
├── codegen/
├── cli/
└── codestart/
----

NOTE: `deployment` and `deployment-spi` have been renamed to `build` and `build-spi`. This is a big change, but Maven relocation will mitigate the breakage.

=== Additional Rules

Module dependencies must follow strict rules:
* `build` depends on `runtime`, and `build-spi` (if defined).
* `runtime` depends on `runtime-api` (if defined).
* External consumers should rely only on `runtime-api` or `build-spi` to be loose-coupled (See <<coupling-api-and-spi>>.).
* External consumers should rely only on `runtime` or `build` to be tightly-coupled (forcing the target extension to be present at execution). See <<coupling-api-and-spi>>.
* Public APIs must be explicitly documented, including build items meant for inter-extension use.
* Public build items must document their intended usage (produced, consumed, or both).
* Each module should provide an `Automatic-Module-Name` based on the root package:

	Runtime:: `io.<quarkus|quarkiverse>.<extension-name>`
	Build:: `io.<quarkus|quarkiverse>.<extension-name>.build`
	Runtime API:: `io.<quarkus|quarkiverse>.<extension-name>.api`
	Build SPI:: `io.<quarkus|quarkiverse>.<extension-name>.build.spi`
	Dev:: `io.<quarkus|quarkiverse>.<extension-name>.dev`
	Codegen:: `io.<quarkus|quarkiverse>.<extension-name>.codegen`
* Each module should have artifact idents following the pattern:

	Runtime:: `quarkus-<extension-name>`
	Build:: `quarkus-<extension-name>-build`
	Runtime API:: `quarkus-<extension-name>-api`
	Build SPI:: `quarkus-<extension-name>-build-spi`
	Dev:: `quarkus-<extension-name>-dev`
	Codegen:: `quarkus-<extension-name>-codegen`
    Codestart:: `quarkus-<extension-name>-codestart`


Using the `Automatic-Module-Name` allows extensions to be used as JPMS modules in the future, even if we do not fully adopt JPMS yet.
Also, it avoids split packages, as the `Automatic-Module-Name` must be unique across all modules in the Quarkus ecosystem.

[#coupling-api-and-spi]
=== Coupling, API and SPI

Historically, Quarkus introduced `spi` modules to separate public APIs from internal implementation details.
However, the distinction between these modules has often been unclear, leading to confusion about their intended use.

There is also a _coupling_ dimension that needs to be taken into account when defining the extension structure.

==== The Coupling Dimension

An extension using another extension can be either strongly or loosely coupled, depending on whether it requires the other extension to be present at runtime:

* Strongly coupled: An extension directly depends on another extension's runtime module (and its `build` to the `build` module), requiring it to be present.
* Loosely coupled: An extension only depends on the public API or SPI of another extension, allowing it to be used without requiring the full extension.

When an extension depends on another extension, it should clearly indicate whether it is tightly or loosely coupled:

* Tightly coupled: The extension depends on the `runtime` or `build` module of another extension, indicating that it requires the full extension to be present.
* Loosely coupled: The extension depends on the `runtime-api` or `build-spi` module of another extension, indicating that it can work independently of the full extension. Note that this may require conditional logic to handle the absence of the extension at runtime.

An extension can also decide to only support _tight-coupling_ and does not provide a `runtime-api` or `build-spi` module.

NOTE: Because of the integration nature of the build items located into the `build-spi` module, we recommend keeping `build-spi` as name.

[#the-place-of-the-public-api]
==== The place of the public API

Historically, extensions have often placed their public APIs in the `runtime` module. This forces a tight coupling between the extension and its consumers, as they must depend on the `runtime` module to access the public API.

To clarify this, we propose the following rules:

* Public APIs should be placed in a dedicated `runtime-api` module, which can be used independently of the full extension.
* The `runtime` module should focus on the internal implementation and runtime logic, delegating public APIs to the `runtime-api` module.
* The `runtime-api` module contains the public API  allowing other extensions to depend on it without pulling in the full extension.

For extensions requiring tight-coupling, the `runtime` module can still be used to expose public APIs, but this should be avoided when possible.

IMPORTANT: Once an extension has a `runtime-api` module, it should not expose public APIs in the `runtime` module. This avoids confusion and ensures that consumers can clearly distinguish between public APIs and internal implementation details. Also, it would not be possible to move the public API back into the `runtime` module.

[cols="1,3,2",options="header"]
|===
| Scenario | Recommended Structure | Notes

| Small/simple extension not reused by others
| `runtime`
| Keep everything in `runtime`. Avoid unnecessary modularity.

| Extension exposes public types used by application code or other extensions
| `runtime-api` + `runtime`
| Split APIs (annotations, interfaces, utility classes) into `runtime-api`. Keep internal logic in `runtime`.

| Extension contributes dev-mode-only logic (e.g., Dev UI)
| `runtime` + `dev`
| Add `dev` to isolate dev-only classes. Avoid shipping to production.

| Extension defines types meant to be implemented by others (e.g., customizers, listeners)
| `runtime-api` + `runtime`
| Consider these types part of the SPI. Place them in `runtime-api` to allow loose coupling.

| Extension wants to enforce tight coupling (full extension must be present)
| `runtime` only
| Expose public types directly from `runtime`. Use cautiously; limits flexibility and reuse.

| Extension depends on or provides code generation
| `runtime` + `codegen`
| Keep codegen logic isolated. Optional, depending on feature set.
|===

=== Package Name Rules

Extensions must use a well-defined package structure to avoid split packages.

[NOTE]
====
In this section, rules are given for the `io.quarkus` and `io.quarkiverse` namespaces.
When the root is different, the rules apply similarly, replacing `io.quarkus` or `io.quarkiverse` with the appropriate root package.
For example: `org.apache.camel.quarkus.component` would use `org.apache.camel.quarkus.component.runtime`, `org.apache.camel.quarkus.component.dev`, etc.
====

==== Root package name

To transform an extension name into a package name, use the following pattern:
* `io.quarkus.<extension-name>` for Quarkus core extensions.
* `io.quarkiverse.<extension-name>` for Quarkiverse extensions.
* If the extension name contains a hyphen, replace it with an underscore (e.g., `quarkus-foo-bar` becomes `io.quarkus.foo_bar`). // TODO Definitely not sure.

==== runtime module
* `io.<quarkus|quarkiverse>.<extension-name>.runtime.internal|impl`: Internal implementation. Not part of the public API.
* `io.<quarkus|quarkiverse>.<extension-name>.runtime.graal`: GraalVM substitutions. Not part of the public API.
* `io.<quarkus|quarkiverse>.<extension-name>`: Public API when requiring tight-coupling. May include subpackages (excluding `api` and `dev` packages). Example: `io.quarkus.cache`. Note that this is discouraged in favor of the `runtime-api` module.

Non-API packages should be under `.impl` or `internal` like `io.quarkus.<extension-name>.runtime.internal` or `io.quarkus.<extension-name>.runtime.impl`.
Thus, automated tooling can easily use this information to help generate a `module-info` with the correct exports, as well as excluding those packages from JavaDoc generation.

==== build module
* `io.<quarkus|quarkiverse>.<extension-name>.build`: Internal build logic (processors, build steps, internal build items). Public SPIs must reside in the `build-spi` module. May include subpackages (excluding `spi`).

==== build-spi module
* `io.<quarkus|quarkiverse>.<extension-name>.build.spi`: Public build items and types. Considered public API and subject to compatibility guarantees.

Build items in this module should be documented with their intended use (produced or consumed).

==== runtime-api module
* `io.<quarkus|quarkiverse>.<extension-name>.api`: Public runtime API. Can be used independently of the full extension. Consumers should not expect the full extension to be available at runtime. To make sure the extension is available, the consumer should use the `runtime` module (which would pull in the `runtime-api` module transitively).

==== dev module
* `io.<quarkus|quarkiverse>.<extension-name>.dev`: Dev-mode-only runtime classes, e.g., for Dev UI contribution. Not included in production builds.

==== codegen module

* `io.<quarkus|quarkiverse>.<extension-name>.codegen`: Code generation logic, if applicable. This module is optional and may not be present in all extensions.


=== Module Summary Table

[cols="1,3,2",options=“header"]
|===
| Module | Purpose | Intended Consumers

| runtime
| Runtime logic and extension internals
| Application code, Quarkus runtime

| runtime-api
| Public runtime APIs and service provider types
| Other extensions, libraries

| build
| Build steps, processor logic, internal build items
| Quarkus build system

| build-spi
| Shared build-time APIs (build items, metadata)
| Other extensions

| dev
| Dev mode–only logic (e.g., Dev UI contributions)
| Development-time only, not production

| codegen
| Code generation logic (if applicable)
| Quarkus build system
|===

== Consequences

=== Positive

	* Improves long-term maintainability and clarity of the codebase.
	* Clarifies the public API surface and encourages proper separation of concerns.
	* Avoids the creation of split packages and internal dependency leakage.
	* Lays the groundwork for potential future adoption of JPMS (Java Platform Module System).

=== Negative

	* Adds structural complexity, which may feel unnecessary for simple extensions.
	* Refactoring existing extensions to adopt this structure requires engineering effort.
	* New contributors must become familiar with the module layout and associated conventions.
	* Some refactoring could break existing extensions and applications, requiring careful migration strategies.


About the last point, extensions can gradually adopt the new structure by first extracting public APIs into a new `runtime-api` module while keeping existing consumers functional. Marking existing runtime types as internal via javadoc or annotations (@Deprecated) can help guide migration.

== Alternatives Considered

* Continuing the current loose structure:
Rejected due to increasing maintenance costs and risk of regressions. After 7 years of evolution, Quarkus needs clearer extension boundaries to remain sustainable.
* Immediate adoption of JPMS (Java Modules):
Deemed too complex and premature. While structurally compatible with this proposal, full JPMS adoption is deferred to avoid breaking changes and complexity in build tooling.

== Related Discussions
	* https://github.com/quarkusio/quarkus/discussions/47074[Discussion: Modular Extension Structure]
	* https://github.com/quarkusio/quarkus/pull/49280[First Implementation (TLS Registry)]

== Notes

This ADR is forward-looking and prescriptive for new extensions or extensions undergoing significant refactoring. It does not require retrofitting all existing extensions immediately. Tooling, documentation, and examples will progressively support the adoption of this structure. The goal is consistency, clarity, and better long-term modularity within the Quarkus ecosystem.